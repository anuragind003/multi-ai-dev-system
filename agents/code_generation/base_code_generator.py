"""
Abstract base class for all code generation agents.
Provides common functionality and standardized interfaces for code generation.
"""

import os
import json
import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional, Union
from datetime import datetime

from langchain_core.language_models import BaseLanguageModel
from langchain_core.retrievers import BaseRetriever
from langchain_core.prompts import ChatPromptTemplate

from agents.base_agent import BaseAgent
from models.data_contracts import GeneratedFile, CodeGenerationOutput
from tools.code_generation_utils import parse_llm_output_into_files
from tools.json_handler import JsonHandler

# Enhanced memory and RAG imports
from enhanced_memory_manager import create_memory_manager, EnhancedSharedProjectMemory
from rag_manager import get_rag_manager

logger = logging.getLogger(__name__)

class BaseCodeGeneratorAgent(BaseAgent, ABC):
    """
    Abstract base class for all code generation agents with standardized I/O.
    Provides common functionality for structured code generation and management.
    """

    def __init__(self, 
                 llm: BaseLanguageModel, 
                 memory, 
                 **kwargs):
        """
        Initialize the base code generator agent.
        
        Args:
            llm: The language model to use for generation
            memory: The memory instance for the agent
            **kwargs: Additional arguments including agent_name, temperature, output_dir, etc.
        """
        super().__init__(
            llm=llm,
            memory=memory,
            **kwargs
        )
        self.output_dir = kwargs.get("output_dir", "output")
        self.code_execution_tool = kwargs.get("code_execution_tool")
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Initialize enhanced memory (inherits from BaseAgent)
        self._init_enhanced_memory()
        
        self.log_info(f"Initialized {self.agent_name} with output directory: {self.output_dir}")

    def run(self, **kwargs) -> Dict[str, Any]:
        """
        Main execution method for the code generator agent.
        This method prepares the environment and calls the concrete `_generate_code` implementation.
        
        Returns:
            Dictionary conforming to the CodeGenerationOutput model
        """
        self.log_start(f"Starting code generation with agent: {self.agent_name}")        
        try:            # Prepare LLM and invoke_config for the generation process
            binding_args = {"temperature": self.default_temperature}
            llm_with_temp = self.llm.bind(**binding_args)
            
            invoke_config = {
                "agent_context": self.agent_name,
                "temperature_used": self.default_temperature,
                "model_name": getattr(self.llm, "model_name", "unknown")
            }

            # Call the subclass's specific generation logic
            generation_result = self._generate_code(
                llm=llm_with_temp,
                invoke_config=invoke_config,
                **kwargs  # Pass all other arguments like requirements_analysis, etc.
            )

            # Ensure the output is a dictionary
            if not isinstance(generation_result, dict):
                 self.log_error("Code generation did not return a dictionary. Returning default.")
                 return self.get_default_response()            # Save files if any were generated
            files_to_save = generation_result.get("files", generation_result.get("generated_files", []))
            if files_to_save:
                self.log_info(f"Saving {len(files_to_save)} generated files to disk.")
                self._save_files(files_to_save)

            # Store result in enhanced memory for cross-tool access
            if generation_result.get("status") == "success":
                self.enhanced_set("code_generation_result", generation_result, context="code_generation")
                if files_to_save:
                    self.store_cross_tool_data("generated_files", files_to_save, f"Files generated by {self.agent_name}")
                
                # Store generation patterns for reuse
                self.enhanced_set("generation_patterns", {
                    "agent": self.agent_name,
                    "file_count": len(files_to_save),
                    "output_dir": self.output_dir,
                    "timestamp": datetime.now().isoformat()
                }, context="generation_patterns")
                
                # Publish code generation completion message
                if hasattr(self, 'message_bus') and self.message_bus:
                    self.message_bus.publish("code.generation.complete", {
                        "agent": self.agent_name,
                        "status": generation_result.get("status", "unknown"),
                        "file_count": len(files_to_save),
                        "output_dir": self.output_dir,
                        "summary": generation_result.get("summary", "Code generation completed")
                    })

            return generation_result

        except Exception as e:
            self.log_error(f"An unhandled exception occurred in {self.agent_name}: {e}", exc_info=True)
            return self.get_default_response()

    @abstractmethod
    def _generate_code(self, llm: BaseLanguageModel, invoke_config: Dict, **kwargs) -> Dict:
        """
        Abstract method for code generation logic. Subclasses must implement this.
        This method is responsible for creating the prompt and invoking the LLM.

        It must return a dictionary that can be parsed by the CodeGenerationOutput model.
        
        Args:
            llm: The temperature-bound language model to use
            invoke_config: Configuration for the LLM invocation
            **kwargs: Additional inputs like requirements_analysis, tech_stack, etc.
            
        Returns:
            Dictionary conforming to the CodeGenerationOutput model        """
        raise NotImplementedError("Subclasses must implement _generate_code method")
    
    def _save_files(self, files) -> None:
        """
        Saves the generated files to the specified output directory.
        
        Args:
            files: List of file objects (CodeFile or GeneratedFile) to save
        """
        if not files:
            self.log_info("No files to save.")
            return

        for file_obj in files:
            try:
                # Handle both CodeFile and GeneratedFile objects
                if hasattr(file_obj, 'code'):
                    # CodeFile object
                    file_path = file_obj.file_path
                    content = file_obj.code
                elif hasattr(file_obj, 'content'):
                    # GeneratedFile object
                    file_path = file_obj.file_path
                    content = file_obj.content
                else:
                    # Dictionary format (legacy)
                    file_path = file_obj.get('file_path', '')
                    content = file_obj.get('content', file_obj.get('code', ''))
                
                # Validate and clean the file path
                if not file_path:
                    self.log_error("File path is empty, skipping file")
                    continue
                
                # Clean the file path of any unwanted characters
                file_path = file_path.strip().strip('\n').strip()
                
                # Remove any markdown artifacts that might have leaked into the path
                if '```' in file_path:
                    file_path = file_path.split('```')[0].strip()
                if '\n' in file_path:
                    file_path = file_path.split('\n')[0].strip()
                
                # Skip if path still contains invalid characters after cleaning
                if '\n' in file_path or '```' in file_path:
                    self.log_error(f"Invalid file path after cleaning: '{file_path}', skipping")
                    continue
                
                # Normalize path separators for Windows
                file_path = file_path.replace('\\', '/')
                
                # Create the full path safely
                full_path = os.path.join(self.output_dir, file_path)
                
                # Additional validation for Windows path length and characters
                if len(full_path) > 260:  # Windows path limit
                    self.log_error(f"File path too long: {full_path}")
                    continue
                
                # Create parent directories if they don't exist
                try:
                    parent_dir = os.path.dirname(full_path)
                    if parent_dir:  # Only create if parent_dir is not empty
                        os.makedirs(parent_dir, exist_ok=True)
                except Exception as dir_error:
                    self.log_error(f"Failed to create directory {parent_dir}: {dir_error}")
                    continue
                
                # Write the file
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                self.log_info(f"Successfully saved file: {file_path}")
                
            except Exception as e:
                error_path = getattr(file_obj, 'file_path', 'unknown')
                self.log_error(f"Failed to save file {error_path}: {e}")                # Log additional debug info for troubleshooting
                if hasattr(file_obj, 'file_path'):
                    newline_char = '\n'
                    backticks = '```'
                    self.log_debug(f"Raw file path: '{repr(file_obj.file_path)}'")
                    self.log_debug(f"File path length: {len(file_obj.file_path)}")
                    self.log_debug(f"File path contains newline: {newline_char in file_obj.file_path}")
                    self.log_debug(f"File path contains backticks: {backticks in file_obj.file_path}")
    
    def _prune_system_design_for_relevance(self, system_design: Dict[str, Any], 
                                          relevant_keys: List[str]) -> Dict[str, Any]:
        """
        Prunes the system design to only include relevant sections.
        
        Args:
            system_design: The complete system design
            relevant_keys: List of top-level keys to preserve
            
        Returns:
            Pruned system design dictionary
        """
        if not isinstance(system_design, dict):
            self.log_warning("System design is not a dictionary. Cannot prune.")
            return {}
            
        pruned = {}
        for key in relevant_keys:
            if key in system_design:
                pruned[key] = system_design[key]
                
        return pruned
    
    def _get_rag_context(self, query: str, use_case: str = None) -> str:
        """
        Retrieves RAG context for code generation.
        
        Args:
            query: The query to use for retrieval
            use_case: Optional use case context
              Returns:
            String containing RAG context
        """
        context = ""
        if self.rag_retriever:
            try:
                if use_case:
                    query = f"[{use_case}] {query}"
                    
                documents = self.rag_retriever.invoke(query)
                context = "\n\n".join([doc.page_content for doc in documents])
                
                if context:
                    self.log_info(f"Retrieved {len(documents)} relevant documents for RAG context")
            except Exception as e:
                self.log_warning(f"Failed to retrieve RAG context: {e}")
                
        return context
                
    def get_default_response(self) -> Dict[str, Any]:
        """
        Provide default response in case of errors.
        Returns a dictionary conforming to the CodeGenerationOutput model.
        
        Returns:
            Default CodeGenerationOutput as dictionary
        """
        return CodeGenerationOutput(
            files=[],
            summary=f"Code generation failed in agent: {self.agent_name}"
        ).dict()