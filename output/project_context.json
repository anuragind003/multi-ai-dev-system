{
    "raw_brd": "# Simple CRUD API for Products\n\n## 1. Introduction\n\nThis document outlines the requirements for a simple RESTful API to manage product information. The API should allow users to create, read, update, and delete product entries.\n\n## 2. Functional Requirements\n\n- **FR1: Create Product:**\n  - Users must be able to add a new product to the system.\n  - A product must have a `name` (string), `description` (string, optional), `price` (float), and `stock_quantity` (integer).\n  - A unique ID should be automatically generated for each product.\n- **FR2: Get All Products:**\n  - Users must be able to retrieve a list of all products.\n  - The list should include all product details (ID, name, description, price, stock_quantity).\n- **FR3: Get Product by ID:**\n  - Users must be able to retrieve details for a specific product using its unique ID.\n- **FR4: Update Product:**\n  - Users must be able to modify an existing product's details (name, description, price, stock_quantity) using its ID.\n  - Partial updates (e.g., updating only the price) should be supported.\n- **FR5: Delete Product:**\n  - Users must be able to remove a product from the system using its ID.\n\n## 3. Non-Functional Requirements\n\n- **NFR1: Performance:** API responses should be fast, ideally within 200ms for common operations.\n- **NFR2: Scalability:** The system should be able to handle up to 100 concurrent requests.\n- **NFR3: Simplicity:** The chosen technology stack should prioritize ease of development and deployment for this initial version.\n- **NFR4: Data Persistence:** Product data must be stored persistently.\n\n## 4. Assumptions\n\n- No user authentication/authorization is required for this initial version.\n- Error handling should be basic (e.g., return 404 for not found, 400 for bad requests).\n- The API will be deployed on a single server.\n",
    "brd_analysis": {
        "summary": "A simple RESTful API is required to manage product information, enabling users to perform Create, Read, Update, and Delete (CRUD) operations on product entries. The API will handle product details such as name, description, price, and stock quantity, with an automatically generated unique ID for each product.",
        "functional_requirements": [
            "FR1: Create Product: Users must be able to add a new product to the system. A product must have a `name` (string), `description` (string, optional), `price` (float), and `stock_quantity` (integer). A unique ID should be automatically generated for each product.",
            "FR2: Get All Products: Users must be able to retrieve a list of all products. The list should include all product details (ID, name, description, price, stock_quantity).",
            "FR3: Get Product by ID: Users must be able to retrieve details for a specific product using its unique ID.",
            "FR4: Update Product: Users must be able to modify an existing product's details (name, description, price, stock_quantity) using its ID. Partial updates (e.g., updating only the price) should be supported.",
            "FR5: Delete Product: Users must be able to remove a product from the system using its ID.",
            ",\n  ",
            ": [\n    ",
            ",\n    ",
            ",\n    ",
            ",\n    "
        ],
        "non_functional_requirements": [
            "NFR1: Performance: API responses should be fast, ideally within 200ms for common operations.",
            "NFR2: Scalability: The system should be able to handle up to 100 concurrent requests.",
            "NFR3: Simplicity: The chosen technology stack should prioritize ease of development and deployment for this initial version.",
            "NFR4: Data Persistence: Product data must be stored persistently."
        ],
        "user_stories": [
            "As a user, I want to add a new product to the system so that I can manage product inventory.",
            "As a user, I want to retrieve a list of all products so that I can view the entire product catalog.",
            "As a user, I want to retrieve details for a specific product using its unique ID so that I can view or verify individual product information.",
            "As a user, I want to modify an existing product's details, including partial updates, using its ID so that I can keep product information accurate and up-to-date.",
            "As a user, I want to remove a product from the system using its ID so that I can manage product availability."
        ],
        "assumptions": [
            "No user authentication/authorization is required for this initial version.",
            "Error handling should be basic (e.g., return 404 for not found, 400 for bad requests).",
            "The API will be deployed on a single server."
        ],
        "ambiguities_or_questions": [
            "Question 1: What are the specific constraints for `price` (e.g., must be positive) and `stock_quantity` (e.g., non-negative)?",
            "Question 2: What method should be used for automatic unique ID generation (e.g., UUID, auto-incrementing integer)?",
            "Question 3: What is the expected API response format for all operations (e.g., JSON)?",
            "Question 4: Are there any requirements for pagination, sorting, or filtering when retrieving all products (FR2)?"
        ]
    },
    "tech_stack_recommendation": {
        "frontend": {
            "name": "None",
            "justification": "The project explicitly defines a 'simple RESTful API' and focuses on backend CRUD operations. There is no mention of a user interface requirement for this initial version, aligning with the 'Simplicity' NFR by keeping the scope focused on the API itself."
        },
        "backend": {
            "name": "Python/Flask",
            "justification": "Flask is a lightweight micro-framework, making it exceptionally easy to learn and use for building simple RESTful APIs. Python's clear syntax and extensive libraries accelerate development, directly addressing the 'Simplicity' NFR and enabling rapid implementation of CRUD operations. It can easily meet the 'Performance' and 'Scalability' requirements for 100 concurrent requests for a simple API."
        },
        "database": {
            "name": "SQLite",
            "justification": "SQLite is a serverless, file-based database, meaning it requires no separate server setup or administration. This makes it incredibly simple to integrate and deploy, perfectly aligning with the 'Simplicity' NFR and the 'single server deployment' assumption. It provides reliable 'Data Persistence' for product information with minimal overhead, ideal for an MVP."
        },
        "overall_rationale": "This technology stack is specifically chosen to maximize simplicity and speed of development for the initial MVP of a RESTful CRUD API. Python/Flask offers a lightweight and developer-friendly backend, while SQLite provides zero-configuration data persistence. This combination allows for rapid implementation, easy deployment on a single server, and meets all functional and non-functional requirements without introducing unnecessary complexity."
    },
    "system_design": {
        "architecture_overview": "A RESTful API backend service using Python/Flask interacting with a SQLite database.",
        "main_modules": [
            "Product Management"
        ],
        "api_endpoints": [
            {
                "path": "/products",
                "method": "POST",
                "description": "Creates a new product with an automatically generated unique ID.",
                "request_body": {
                    "name": "string",
                    "description": "string",
                    "price": 0.0,
                    "stock_quantity": 0
                },
                "response_example": {
                    "id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
                    "name": "Example Product",
                    "description": "A detailed description of the example product.",
                    "price": 19.99,
                    "stock_quantity": 100
                }
            },
            {
                "path": "/products",
                "method": "GET",
                "description": "Retrieves a list of all products.",
                "response_example": [
                    {
                        "id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
                        "name": "Product A",
                        "description": "Description for Product A",
                        "price": 10.5,
                        "stock_quantity": 50
                    },
                    {
                        "id": "b2c3d4e5-f6a7-8901-2345-67890abcdef1",
                        "name": "Product B",
                        "description": "Description for Product B",
                        "price": 25.0,
                        "stock_quantity": 20
                    }
                ]
            },
            {
                "path": "/products/<string:product_id>",
                "method": "GET",
                "description": "Retrieves details for a specific product using its unique ID.",
                "response_example": {
                    "id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
                    "name": "Example Product",
                    "description": "A detailed description of the example product.",
                    "price": 19.99,
                    "stock_quantity": 100
                }
            },
            {
                "path": "/products/<string:product_id>",
                "method": "PUT",
                "description": "Updates an existing product's details. Supports partial updates by only including fields to be modified.",
                "request_body": {
                    "name": "string",
                    "description": "string",
                    "price": 0.0,
                    "stock_quantity": 0
                },
                "response_example": {
                    "id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
                    "name": "Updated Product Name",
                    "description": "Updated description.",
                    "price": 22.5,
                    "stock_quantity": 95
                }
            },
            {
                "path": "/products/<string:product_id>",
                "method": "DELETE",
                "description": "Removes a product from the system using its unique ID.",
                "response_example": {
                    "message": "Product deleted successfully"
                }
            }
        ],
        "database_schema": "CREATE TABLE products (\n    id TEXT PRIMARY KEY,\n    name TEXT NOT NULL,\n    description TEXT,\n    price REAL NOT NULL,\n    stock_quantity INTEGER NOT NULL\n);",
        "design_notes": [
            "All product IDs should be unique identifiers (e.g., UUIDs) generated by the backend.",
            "Basic error handling should return standard HTTP status codes: 404 Not Found for non-existent resources and 400 Bad Request for invalid input data.",
            "No user authentication or authorization is required for this initial MVP version.",
            "Partial updates for PUT /products/{id} should be implemented by checking for the presence of fields in the request body and updating only those provided.",
            "The system will be deployed on a single server, leveraging Flask's simplicity and SQLite's file-based nature for ease of development and deployment."
        ]
    },
    "generated_codebase_files": {
        "README.md": "## Product Management API\n\nThis is a simple RESTful API for managing product information, built with Python and Flask, using SQLite for data persistence.",
        "requirements.txt": "Flask\nFlask-RESTful (optional, for simpler API development)\nFlask-SQLAlchemy (optional, for ORM)\nSQLAlchemy (if not using Flask-SQLAlchemy)\npython-dotenv (for environment variables)",
        ".gitignore": "# Python\n__pycache__/\n*.pyc\n.pytest_cache/\n.venv/\nenv/\ninstance/\n\n# Database\n*.db\n*.sqlite3",
        "run.py": "from app import app\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "instance/app.db": "# SQLite database file. This file will be created and managed by the application.",
        "app/__init__.py": "import os\nfrom flask import Flask\n\ndef create_app():\n    \"\"\"\n    Creates and configures the Flask application instance.\n\n    This function sets up the Flask application, including:\n    - Creating the application instance with instance-relative configuration.\n    - Ensuring the instance folder exists for storing database files.\n    - Configuring the SQLite database path.\n    - Initializing the database connection and schema.\n    - Registering the product management blueprint for API routes.\n    \"\"\"\n    app = Flask(__name__, instance_relative_config=True)\n\n    # Ensure the instance folder exists\n    # This folder is used to store the SQLite database file.\n    try:\n        os.makedirs(app.instance_path, exist_ok=True)\n    except OSError:\n        # In a production environment, more robust error handling might be needed here,\n        # e.g., logging the error or raising a specific exception.\n        # For this simple application, exist_ok=True handles most cases.\n        pass\n\n    # Configure the database path\n    # The database file will be located in the 'instance' folder.\n    app.config.from_mapping(\n        DATABASE=os.path.join(app.instance_path, 'products.sqlite'),\n    )\n\n    # Initialize the database\n    # This imports the db module and calls its init_app function\n    # to register database-related commands and teardown functions.\n    from . import db\n    db.init_app(app)\n\n    # Register blueprints\n    # This imports the products blueprint and registers it with the app.\n    # All routes defined in the products blueprint will be accessible.\n    from . import products\n    app.register_blueprint(products.bp)\n\n    # A simple test route to verify the app is running\n    @app.route('/hello')\n    def hello():\n        return 'Hello, World!'\n\n    return app",
        "app/config.py": "import os\n\n# Determine the base directory of the application.\n# This assumes config.py is located in the 'app' directory,\n# and the database file will be one level up (in the project root).\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\nclass Config:\n    \"\"\"Base configuration class with common settings.\"\"\"\n    # A secret key is essential for Flask applications for session management,\n    # CSRF protection, etc. For development, a hardcoded key is used as a fallback.\n    # In a production environment, SECRET_KEY MUST be set via environment variables\n    # and should be a strong, randomly generated string.\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'a_very_secret_key_for_development_and_testing_only'\n\n    # Database configuration for SQLite\n    DATABASE_NAME = 'products.db'\n    # The database file will be located in the project root directory.\n    DATABASE_PATH = os.path.join(basedir, '..', DATABASE_NAME)\n\nclass DevelopmentConfig(Config):\n    \"\"\"Development specific configuration.\"\"\"\n    DEBUG = True\n    # For development, we use the default database path defined in Config.\n    # If a separate development database file was desired, it could be overridden here.\n    # Example: DATABASE_NAME = 'products_dev.db'\n    #          DATABASE_PATH = os.path.join(basedir, '..', DATABASE_NAME)\n\nclass TestingConfig(Config):\n    \"\"\"Testing specific configuration.\"\"\"\n    TESTING = True\n    DEBUG = True  # Often useful to see full tracebacks during testing.\n    # Use an in-memory SQLite database for testing for isolation and speed.\n    # This means the database is created in RAM and cleared after the application stops.\n    DATABASE_NAME = ':memory:' # Special name for in-memory SQLite\n    DATABASE_PATH = DATABASE_NAME # Path is just the special name for in-memory\n\nclass ProductionConfig(Config):\n    \"\"\"Production specific configuration.\"\"\"\n    DEBUG = False\n    TESTING = False\n    # In production, SECRET_KEY should always be provided via environment variables.\n    # The base Config provides a fallback, but for a real production system,\n    # it's critical to ensure this is set externally.\n    # For this MVP, the fallback is acceptable as per the simplicity NFR.",
        "app/db.py": "import sqlite3\nimport uuid\n\nimport click\nfrom flask import current_app, g\nfrom flask.cli import with_appcontext\n\n\ndef get_db():\n    \"\"\"\n    Establishes a database connection or returns the existing one for the current request.\n    The connection is stored in Flask's `g` object to ensure it's reused within the same request.\n    `sqlite3.Row` is used as the row factory to allow dictionary-like access to query results.\n    \"\"\"\n    if 'db' not in g:\n        g.db = sqlite3.connect(\n            current_app.config['DATABASE'],\n            detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n    return g.db\n\n\ndef close_db(e=None):\n    \"\"\"\n    Closes the database connection if it exists in Flask's `g` object.\n    This function is registered as a teardown function for the Flask application context,\n    ensuring the database connection is closed at the end of each request.\n    \"\"\"\n    db = g.pop('db', None)\n    if db is not None:\n        db.close()\n\n\ndef init_db():\n    \"\"\"\n    Initializes the database by executing the schema.sql script.\n    This creates the necessary tables (e.g., 'products') if they don't exist.\n    \"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql') as f:\n        db.executescript(f.read().decode('utf8'))\n\n\n@click.command('init-db')\n@with_appcontext\ndef init_db_command():\n    \"\"\"\n    A Flask CLI command to initialize the database.\n    Usage: `flask init-db`\n    This command will clear any existing data and create new tables based on `schema.sql`.\n    \"\"\"\n    init_db()\n    click.echo('Initialized the database.')\n\n\ndef init_app(app):\n    \"\"\"\n    Registers database-related functions with the Flask application instance.\n    - `close_db` is registered as a teardown function.\n    - `init_db_command` is added to the Flask CLI.\n    \"\"\"\n    app.teardown_appcontext(close_db)\n    app.cli.add_command(init_db_command)\n\n\n# --- CRUD Operations for Products ---\n\ndef create_product(name, description, price, stock_quantity):\n    \"\"\"\n    Inserts a new product into the database.\n    A unique ID (UUID) is automatically generated for the product.\n    Returns the dictionary representation of the newly created product.\n    \"\"\"\n    db = get_db()\n    product_id = str(uuid.uuid4())\n    cursor = db.cursor()\n    cursor.execute(\n        \"INSERT INTO products (id, name, description, price, stock_quantity) VALUES (?, ?, ?, ?, ?)\",\n        (product_id, name, description, price, stock_quantity)\n    )\n    db.commit()\n    return {\n        \"id\": product_id,\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"stock_quantity\": stock_quantity\n    }\n\n\ndef get_all_products():\n    \"\"\"\n    Retrieves all products from the database.\n    Returns a list of dictionaries, where each dictionary represents a product.\n    \"\"\"\n    db = get_db()\n    products = db.execute(\n        \"SELECT id, name, description, price, stock_quantity FROM products\"\n    ).fetchall()\n    return [dict(product) for product in products]\n\n\ndef get_product_by_id(product_id):\n    \"\"\"\n    Retrieves a single product by its unique ID.\n    Returns a dictionary representing the product if found, otherwise None.\n    \"\"\"\n    db = get_db()\n    product = db.execute(\n        \"SELECT id, name, description, price, stock_quantity FROM products WHERE id = ?\",\n        (product_id,)\n    ).fetchone()\n    return dict(product) if product else None\n\n\ndef update_product(product_id, data):\n    \"\"\"\n    Updates an existing product's details. Supports partial updates.\n    Only the fields present in the `data` dictionary will be updated.\n    Returns the dictionary representation of the updated product if found, otherwise None.\n    \"\"\"\n    db = get_db()\n    current_product = get_product_by_id(product_id)\n    if not current_product:\n        return None\n\n    set_clauses = []\n    params = []\n    # Iterate through allowed updateable fields and build query dynamically\n    for key, value in data.items():\n        if key in [\"name\", \"description\", \"price\", \"stock_quantity\"]:\n            set_clauses.append(f\"{key} = ?\")\n            params.append(value)\n\n    if not set_clauses:\n        # No valid fields provided for update, return current product state\n        return current_product\n\n    params.append(product_id)  # Add product_id for the WHERE clause\n\n    query = f\"UPDATE products SET {', '.join(set_clauses)} WHERE id = ?\"\n    cursor = db.cursor()\n    cursor.execute(query, tuple(params))\n    db.commit()\n\n    # Fetch and return the updated product to confirm changes\n    return get_product_by_id(product_id)\n\n\ndef delete_product(product_id):\n    \"\"\"\n    Deletes a product from the database by its ID.\n    Returns True if the product was successfully deleted, False if not found.\n    \"\"\"\n    db = get_db()\n    cursor = db.cursor()\n    cursor.execute(\"DELETE FROM products WHERE id = ?\", (product_id,))\n    db.commit()\n    # Check if any row was actually deleted\n    return cursor.rowcount > 0",
        "app/models.py": "from flask_sqlalchemy import SQLAlchemy\nimport uuid\n\ndb = SQLAlchemy()\n\nclass Product(db.Model):\n    \"\"\"\n    Product model representing a product in the inventory.\n    Maps to the 'products' table in the database.\n    \"\"\"\n    __tablename__ = 'products'\n\n    id = db.Column(db.Text, primary_key=True, default=lambda: str(uuid.uuid4()))\n    name = db.Column(db.Text, nullable=False)\n    description = db.Column(db.Text, nullable=True)\n    price = db.Column(db.Float, nullable=False)\n    stock_quantity = db.Column(db.Integer, nullable=False)\n\n    def __repr__(self):\n        \"\"\"\n        Returns a string representation of the Product object.\n        \"\"\"\n        return f\"<Product {self.id}: {self.name}>\"\n\n    def to_dict(self):\n        \"\"\"\n        Converts the Product object to a dictionary, suitable for JSON serialization.\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"price\": self.price,\n            \"stock_quantity\": self.stock_quantity,\n        }",
        "app/routes/__init__.py": "from flask import Flask\nfrom app.database import init_db\nfrom .product_routes import product_bp\n\ndef create_app():\n    \"\"\"\n    Creates and configures the Flask application.\n    This function initializes the database and registers blueprints.\n    \"\"\"\n    app = Flask(__name__)\n\n    # Initialize the database\n    # This ensures the database schema is created when the app starts.\n    # It's good practice to do this within an application context.\n    with app.app_context():\n        init_db()\n\n    # Register blueprints\n    # The product_bp blueprint will handle all product-related API endpoints.\n    app.register_blueprint(product_bp)\n\n    return app",
        "app/routes/products.py": "import sqlite3\nimport uuid\nfrom flask import Blueprint, request, jsonify, g, current_app\n\n# Create a Blueprint for product routes\nproducts_bp = Blueprint('products', __name__, url_prefix='/products')\n\n# Define the database path. In a larger app, this would be in a config file.\nDATABASE = 'database.db'\n\ndef get_db():\n    \"\"\"\n    Establishes a database connection if one is not already present for the current request.\n    The connection is stored in Flask's `g` object.\n    \"\"\"\n    if 'db' not in g:\n        g.db = sqlite3.connect(\n            DATABASE,\n            detect_types=sqlite3.PARSE_DECLTYPES # This helps with type conversion for dates/times if used\n        )\n        g.db.row_factory = sqlite3.Row # This allows accessing columns by name\n    return g.db\n\n@products_bp.teardown_request\ndef close_db(exception):\n    \"\"\"\n    Closes the database connection at the end of the request.\n    This function is registered with the blueprint's teardown_request.\n    \"\"\"\n    db = g.pop('db', None)\n    if db is not None:\n        db.close()\n\ndef row_to_dict(row):\n    \"\"\"\n    Converts a sqlite3.Row object to a standard Python dictionary.\n    This is useful for jsonify responses.\n    \"\"\"\n    return dict(row)\n\n@products_bp.route('/', methods=['POST'])\ndef create_product():\n    \"\"\"\n    API endpoint to create a new product.\n    Requires 'name', 'price', 'stock_quantity' in the JSON request body.\n    'description' is optional.\n    Returns the newly created product with a 201 status code on success.\n    Handles 400 Bad Request for invalid input.\n    \"\"\"\n    data = request.get_json()\n\n    if not data:\n        return jsonify({\"error\": \"Request must be JSON\"}), 400\n\n    name = data.get('name')\n    price = data.get('price')\n    stock_quantity = data.get('stock_quantity')\n    description = data.get('description')\n\n    # Validate required fields\n    if not name or not isinstance(name, str):\n        return jsonify({\"error\": \"Product name (string) is required\"}), 400\n    if price is None:\n        return jsonify({\"error\": \"Product price is required\"}), 400\n    if stock_quantity is None:\n        return jsonify({\"error\": \"Product stock_quantity is required\"}), 400\n\n    # Validate data types and constraints\n    try:\n        price = float(price)\n        if price < 0:\n            return jsonify({\"error\": \"Price must be a non-negative number\"}), 400\n    except (ValueError, TypeError):\n        return jsonify({\"error\": \"Price must be a valid number\"}), 400\n\n    try:\n        stock_quantity = int(stock_quantity)\n        if stock_quantity < 0:\n            return jsonify({\"error\": \"Stock quantity must be a non-negative integer\"}), 400\n    except (ValueError, TypeError):\n        return jsonify({\"error\": \"Stock quantity must be a valid integer\"}), 400\n\n    if description is not None and not isinstance(description, str):\n        return jsonify({\"error\": \"Description must be a string or null\"}), 400\n\n    product_id = str(uuid.uuid4()) # Generate a unique ID\n\n    db = get_db()\n    try:\n        db.execute(\n            \"INSERT INTO products (id, name, description, price, stock_quantity) VALUES (?, ?, ?, ?, ?)\",\n            (product_id, name, description, price, stock_quantity)\n        )\n        db.commit()\n    except sqlite3.Error as e:\n        current_app.logger.error(f\"Database error during product creation: {e}\")\n        return jsonify({\"error\": \"Failed to create product due to database error\"}), 500\n\n    new_product = {\n        \"id\": product_id,\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"stock_quantity\": stock_quantity\n    }\n    return jsonify(new_product), 201\n\n@products_bp.route('/', methods=['GET'])\ndef get_all_products():\n    \"\"\"\n    API endpoint to retrieve a list of all products.\n    Returns a JSON array of product objects.\n    \"\"\"\n    db = get_db()\n    products = db.execute(\"SELECT * FROM products\").fetchall()\n    return jsonify([row_to_dict(product) for product in products]), 200\n\n@products_bp.route('/<string:product_id>', methods=['GET'])\ndef get_product_by_id(product_id):\n    \"\"\"\n    API endpoint to retrieve details for a specific product by its ID.\n    Returns the product object if found, or 404 Not Found.\n    \"\"\"\n    db = get_db()\n    product = db.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,)).fetchone()\n\n    if product is None:\n        return jsonify({\"error\": \"Product not found\"}), 404\n    return jsonify(row_to_dict(product)), 200\n\n@products_bp.route('/<string:product_id>', methods=['PUT'])\ndef update_product(product_id):\n    \"\"\"\n    API endpoint to update an existing product's details.\n    Supports partial updates: only fields provided in the JSON body will be updated.\n    Returns the updated product object if successful, or 404 Not Found/400 Bad Request.\n    \"\"\"\n    data = request.get_json()\n\n    if not data:\n        return jsonify({\"error\": \"Request must be JSON\"}), 400\n\n    db = get_db()\n    product = db.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,)).fetchone()\n\n    if product is None:\n        return jsonify({\"error\": \"Product not found\"}), 404\n\n    # Convert product row to dict for easier modification and to build the response\n    updated_product_data = row_to_dict(product)\n\n    # Prepare for dynamic update query\n    update_fields = []\n    update_values = []\n\n    # Check and update fields if provided in the request body\n    if 'name' in data:\n        if not isinstance(data['name'], str) or not data['name']:\n            return jsonify({\"error\": \"Name must be a non-empty string\"}), 400\n        update_fields.append(\"name = ?\")\n        update_values.append(data['name'])\n        updated_product_data['name'] = data['name']\n\n    if 'description' in data:\n        # Description can be null, so check for string or None\n        if not isinstance(data['description'], (str, type(None))):\n            return jsonify({\"error\": \"Description must be a string or null\"}), 400\n        update_fields.append(\"description = ?\")\n        update_values.append(data['description'])\n        updated_product_data['description'] = data['description']\n\n    if 'price' in data:\n        try:\n            price = float(data['price'])\n            if price < 0:\n                return jsonify({\"error\": \"Price must be a non-negative number\"}), 400\n            update_fields.append(\"price = ?\")\n            update_values.append(price)\n            updated_product_data['price'] = price\n        except (ValueError, TypeError):\n            return jsonify({\"error\": \"Price must be a valid number\"}), 400\n\n    if 'stock_quantity' in data:\n        try:\n            stock_quantity = int(data['stock_quantity'])\n            if stock_quantity < 0:\n                return jsonify({\"error\": \"Stock quantity must be a non-negative integer\"}), 400\n            update_fields.append(\"stock_quantity = ?\")\n            update_values.append(stock_quantity)\n            updated_product_data['stock_quantity'] = stock_quantity\n        except (ValueError, TypeError):\n            return jsonify({\"error\": \"Stock quantity must be a valid integer\"}), 400\n\n    # If no valid fields were provided for update, return 200 with current data\n    if not update_fields:\n        return jsonify({\"message\": \"No valid fields provided for update, product remains unchanged\",\n                        \"product\": updated_product_data}), 200\n\n    update_query = \"UPDATE products SET \" + \", \".join(update_fields) + \" WHERE id = ?\"\n    update_values.append(product_id)\n\n    try:\n        db.execute(update_query, tuple(update_values))\n        db.commit()\n    except sqlite3.Error as e:\n        current_app.logger.error(f\"Database error during product update: {e}\")\n        return jsonify({\"error\": \"Failed to update product due to database error\"}), 500\n\n    return jsonify(updated_product_data), 200\n\n@products_bp.route('/<string:product_id>', methods=['DELETE'])\ndef delete_product(product_id):\n    \"\"\"\n    API endpoint to remove a product from the system by its ID.\n    Returns a success message with 200 status, or 404 Not Found.\n    \"\"\"\n    db = get_db()\n    cursor = db.execute(\"DELETE FROM products WHERE id = ?\", (product_id,))\n    db.commit()\n\n    if cursor.rowcount == 0:\n        return jsonify({\"error\": \"Product not found\"}), 404\n    return jsonify({\"message\": \"Product deleted successfully\"}), 200",
        "app/utils.py": "import sqlite3\nimport uuid\nimport os\n\nDATABASE = 'database.db'\n\ndef get_db_connection():\n    \"\"\"\n    Establishes a connection to the SQLite database.\n    Sets row_factory to sqlite3.Row to allow dictionary-like access to rows.\n    \"\"\"\n    conn = sqlite3.connect(DATABASE)\n    conn.row_factory = sqlite3.Row\n    return conn\n\ndef init_db():\n    \"\"\"\n    Initializes the database by creating the 'products' table if it doesn't exist.\n    This function should be called once, typically at application startup.\n    \"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS products (\n            id TEXT PRIMARY KEY,\n            name TEXT NOT NULL,\n            description TEXT,\n            price REAL NOT NULL,\n            stock_quantity INTEGER NOT NULL\n        );\n    \"\"\")\n    conn.commit()\n    conn.close()\n\ndef generate_uuid():\n    \"\"\"\n    Generates a unique identifier (UUID) for product IDs.\n    \"\"\"\n    return str(uuid.uuid4())\n\ndef validate_product_data(data, is_update=False):\n    \"\"\"\n    Validates product data for creation or update.\n\n    Args:\n        data (dict): The dictionary containing product data.\n        is_update (bool): True if validating for an update (allows partial data), False for creation.\n\n    Returns:\n        tuple: A tuple containing (is_valid, error_message).\n    \"\"\"\n    required_fields = ['name', 'price', 'stock_quantity']\n    errors = []\n\n    if not is_update:\n        for field in required_fields:\n            if field not in data:\n                errors.append(f\"Missing required field: '{field}'\")\n    \n    if 'name' in data and not isinstance(data['name'], str):\n        errors.append(\"Name must be a string.\")\n    elif 'name' in data and not data['name'].strip():\n        errors.append(\"Name cannot be empty.\")\n\n    if 'description' in data and not isinstance(data['description'], str):\n        errors.append(\"Description must be a string.\")\n\n    if 'price' in data:\n        try:\n            price = float(data['price'])\n            if price <= 0:\n                errors.append(\"Price must be a positive number.\")\n        except (ValueError, TypeError):\n            errors.append(\"Price must be a valid number.\")\n\n    if 'stock_quantity' in data:\n        try:\n            stock_quantity = int(data['stock_quantity'])\n            if stock_quantity < 0:\n                errors.append(\"Stock quantity cannot be negative.\")\n        except (ValueError, TypeError):\n            errors.append(\"Stock quantity must be a valid integer.\")\n\n    if errors:\n        return False, \", \".join(errors)\n    return True, None\n\n# Ensure the database directory exists if needed (though for single file, not strictly necessary)\n# if not os.path.exists(os.path.dirname(DATABASE)):\n#     os.makedirs(os.path.dirname(DATABASE))\n\n# Call init_db() when this module is imported to ensure the table exists\n# This is a common pattern for simple Flask apps with SQLite.\ninit_db()",
        "app/errors.py": "from flask import jsonify\nfrom werkzeug.exceptions import HTTPException\n\nclass APIError(HTTPException):\n    \"\"\"\n    Custom exception class for API errors.\n    Inherits from HTTPException to allow Flask's error handling mechanism\n    to automatically catch and process it, returning a JSON response.\n    \"\"\"\n    def __init__(self, message, status_code):\n        # HTTPException constructor takes description and optionally response\n        super().__init__(description=message)\n        self.code = status_code  # Set the HTTP status code for this exception\n\n    def get_body(self, environ=None):\n        \"\"\"\n        Overrides get_body to return the JSON error message.\n        \"\"\"\n        return jsonify({\"message\": self.description}).get_data(as_text=True)\n\n    def get_headers(self, environ=None):\n        \"\"\"\n        Overrides get_headers to ensure Content-Type is application/json.\n        \"\"\"\n        return [('Content-Type', 'application/json')]\n\ndef register_error_handlers(app):\n    \"\"\"\n    Registers custom error handlers with the Flask application.\n    \"\"\"\n\n    @app.errorhandler(APIError)\n    def handle_api_error(error):\n        \"\"\"\n        Handler for custom APIError exceptions.\n        Since APIError inherits from HTTPException, Flask will automatically\n        call its get_response method. We can simply return the error object.\n        \"\"\"\n        return error\n\n    @app.errorhandler(404)\n    def handle_not_found_error(error):\n        \"\"\"\n        Handler for 404 Not Found errors.\n        Returns a JSON response for consistency.\n        \"\"\"\n        response = jsonify({\"message\": \"Resource not found\"})\n        response.status_code = 404\n        return response\n\n    @app.errorhandler(400)\n    def handle_bad_request_error(error):\n        \"\"\"\n        Handler for 400 Bad Request errors.\n        This can catch errors from Flask's request parsing (e.g., malformed JSON,\n        missing required fields if handled by Flask's default parsers).\n        Returns a JSON response.\n        \"\"\"\n        # Werkzeug's BadRequest (which is a 400 HTTPException) has a description.\n        # Use it if available, otherwise a generic message.\n        message = getattr(error, 'description', 'Bad request')\n        response = jsonify({\"message\": message})\n        response.status_code = 400\n        return response\n\n    @app.errorhandler(500)\n    def handle_internal_server_error(error):\n        \"\"\"\n        Handler for 500 Internal Server Error.\n        Catches unhandled exceptions that result in a 500.\n        Returns a JSON response.\n        \"\"\"\n        response = jsonify({\"message\": \"An unexpected error occurred.\"})\n        response.status_code = 500\n        return response\n\n    @app.errorhandler(Exception)\n    def handle_generic_exception(e):\n        \"\"\"\n        Catch-all handler for any other unhandled exceptions.\n        This ensures all errors return a consistent JSON format, even for\n        unexpected server errors.\n        \"\"\"\n        # Log the exception for debugging purposes\n        app.logger.error(f\"Unhandled exception: {e}\", exc_info=True)\n        response = jsonify({\"message\": \"An unexpected error occurred.\"})\n        response.status_code = 500\n        return response",
        "tests/__init__.py": "\"\"\"\nInitializes the 'tests' Python package.\n\"\"\"",
        "tests/conftest.py": "import pytest\nfrom src.app import create_app, init_db\n\n@pytest.fixture\ndef app():\n    \"\"\"Create and configure a new app instance for each test.\"\"\"\n    app = create_app({\n        'TESTING': True,\n        'DATABASE': ':memory:',  # Use in-memory SQLite for tests\n    })\n\n    with app.app_context():\n        # Initialize the database schema for the test database.\n        # This calls the init_db function from src/app.py,\n        # which should execute the schema creation SQL.\n        init_db()\n\n    yield app\n\n@pytest.fixture\ndef client(app):\n    \"\"\"A test client for the app.\"\"\"\n    return app.test_client()\n\n@pytest.fixture\ndef runner(app):\n    \"\"\"A test CLI runner for the app.\"\"\"\n    return app.test_cli_runner()",
        "tests/test_products_api.py": "import pytest\nimport json\nimport uuid\n\n# Assuming the Flask app and database initialization functions are in 'app.py'\n# We need to import them to set up the test environment.\n# The 'app' module should expose a function like 'create_app'\n# and a function like 'init_db' that sets up the database schema.\nfrom app import create_app, init_db\n\n\n@pytest.fixture\ndef client():\n    \"\"\"\n    Configures the Flask app for testing, sets up an in-memory SQLite database,\n    initializes the database schema, and provides a test client.\n    \"\"\"\n    app = create_app()\n    app.config['TESTING'] = True\n    # Use an in-memory SQLite database for testing\n    app.config['DATABASE'] = ':memory:'\n\n    with app.test_client() as client:\n        # Push an application context to initialize the database\n        with app.app_context():\n            init_db()\n        yield client\n\n\ndef test_create_product_success(client):\n    \"\"\"\n    Tests successful creation of a new product.\n    \"\"\"\n    product_data = {\n        \"name\": \"Test Product\",\n        \"description\": \"A product for testing purposes.\",\n        \"price\": 99.99,\n        \"stock_quantity\": 10\n    }\n    response = client.post(\"/products\", json=product_data)\n    data = json.loads(response.data)\n\n    assert response.status_code == 201\n    assert \"id\" in data\n    assert data[\"name\"] == product_data[\"name\"]\n    assert data[\"description\"] == product_data[\"description\"]\n    assert data[\"price\"] == product_data[\"price\"]\n    assert data[\"stock_quantity\"] == product_data[\"stock_quantity\"]\n\n\ndef test_create_product_missing_required_fields(client):\n    \"\"\"\n    Tests creating a product with missing required fields.\n    \"\"\"\n    # Missing 'name'\n    product_data = {\n        \"description\": \"A product for testing purposes.\",\n        \"price\": 99.99,\n        \"stock_quantity\": 10\n    }\n    response = client.post(\"/products\", json=product_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n    # Missing 'price'\n    product_data = {\n        \"name\": \"Test Product\",\n        \"description\": \"A product for testing purposes.\",\n        \"stock_quantity\": 10\n    }\n    response = client.post(\"/products\", json=product_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n    # Missing 'stock_quantity'\n    product_data = {\n        \"name\": \"Test Product\",\n        \"description\": \"A product for testing purposes.\",\n        \"price\": 99.99\n    }\n    response = client.post(\"/products\", json=product_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n\ndef test_create_product_invalid_data_types(client):\n    \"\"\"\n    Tests creating a product with invalid data types for fields.\n    \"\"\"\n    product_data = {\n        \"name\": \"Test Product\",\n        \"description\": \"A product for testing purposes.\",\n        \"price\": \"invalid_price\",  # Invalid type\n        \"stock_quantity\": 10\n    }\n    response = client.post(\"/products\", json=product_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n    product_data = {\n        \"name\": \"Test Product\",\n        \"description\": \"A product for testing purposes.\",\n        \"price\": 99.99,\n        \"stock_quantity\": \"invalid_stock\"  # Invalid type\n    }\n    response = client.post(\"/products\", json=product_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n\ndef test_get_all_products_empty(client):\n    \"\"\"\n    Tests retrieving all products when no products exist.\n    \"\"\"\n    response = client.get(\"/products\")\n    data = json.loads(response.data)\n\n    assert response.status_code == 200\n    assert isinstance(data, list)\n    assert len(data) == 0\n\n\ndef test_get_all_products_with_data(client):\n    \"\"\"\n    Tests retrieving all products when products exist.\n    \"\"\"\n    product1_data = {\n        \"name\": \"Product A\",\n        \"description\": \"Desc A\",\n        \"price\": 10.0,\n        \"stock_quantity\": 100\n    }\n    product2_data = {\n        \"name\": \"Product B\",\n        \"description\": \"Desc B\",\n        \"price\": 20.0,\n        \"stock_quantity\": 200\n    }\n    client.post(\"/products\", json=product1_data)\n    client.post(\"/products\", json=product2_data)\n\n    response = client.get(\"/products\")\n    data = json.loads(response.data)\n\n    assert response.status_code == 200\n    assert isinstance(data, list)\n    assert len(data) == 2\n    # Check if the names are present in the returned list\n    assert any(p[\"name\"] == \"Product A\" for p in data)\n    assert any(p[\"name\"] == \"Product B\" for p in data)\n\n\ndef test_get_product_by_id_success(client):\n    \"\"\"\n    Tests retrieving a specific product by its ID successfully.\n    \"\"\"\n    product_data = {\n        \"name\": \"Unique Product\",\n        \"description\": \"Description for unique product.\",\n        \"price\": 50.0,\n        \"stock_quantity\": 5\n    }\n    post_response = client.post(\"/products\", json=product_data)\n    created_product = json.loads(post_response.data)\n    product_id = created_product[\"id\"]\n\n    get_response = client.get(f\"/products/{product_id}\")\n    retrieved_product = json.loads(get_response.data)\n\n    assert get_response.status_code == 200\n    assert retrieved_product[\"id\"] == product_id\n    assert retrieved_product[\"name\"] == product_data[\"name\"]\n    assert retrieved_product[\"price\"] == product_data[\"price\"]\n\n\ndef test_get_product_by_id_not_found(client):\n    \"\"\"\n    Tests retrieving a product with a non-existent ID.\n    \"\"\"\n    non_existent_id = str(uuid.uuid4())  # Generate a valid-looking but non-existent UUID\n    response = client.get(f\"/products/{non_existent_id}\")\n    assert response.status_code == 404\n    assert \"error\" in json.loads(response.data)\n\n\ndef test_update_product_full_success(client):\n    \"\"\"\n    Tests full update of an existing product.\n    \"\"\"\n    product_data = {\n        \"name\": \"Original Product\",\n        \"description\": \"Original description.\",\n        \"price\": 10.0,\n        \"stock_quantity\": 10\n    }\n    post_response = client.post(\"/products\", json=product_data)\n    created_product = json.loads(post_response.data)\n    product_id = created_product[\"id\"]\n\n    updated_data = {\n        \"name\": \"Updated Product\",\n        \"description\": \"New description.\",\n        \"price\": 15.0,\n        \"stock_quantity\": 15\n    }\n    put_response = client.put(f\"/products/{product_id}\", json=updated_data)\n    updated_product = json.loads(put_response.data)\n\n    assert put_response.status_code == 200\n    assert updated_product[\"id\"] == product_id\n    assert updated_product[\"name\"] == updated_data[\"name\"]\n    assert updated_product[\"description\"] == updated_data[\"description\"]\n    assert updated_product[\"price\"] == updated_data[\"price\"]\n    assert updated_product[\"stock_quantity\"] == updated_data[\"stock_quantity\"]\n\n    # Verify by fetching again\n    get_response = client.get(f\"/products/{product_id}\")\n    verified_product = json.loads(get_response.data)\n    assert verified_product[\"name\"] == updated_data[\"name\"]\n\n\ndef test_update_product_partial_success(client):\n    \"\"\"\n    Tests partial update of an existing product.\n    \"\"\"\n    product_data = {\n        \"name\": \"Original Product\",\n        \"description\": \"Original description.\",\n        \"price\": 10.0,\n        \"stock_quantity\": 10\n    }\n    post_response = client.post(\"/products\", json=product_data)\n    created_product = json.loads(post_response.data)\n    product_id = created_product[\"id\"]\n\n    partial_update_data = {\n        \"price\": 12.5,\n        \"stock_quantity\": 8\n    }\n    put_response = client.put(f\"/products/{product_id}\", json=partial_update_data)\n    updated_product = json.loads(put_response.data)\n\n    assert put_response.status_code == 200\n    assert updated_product[\"id\"] == product_id\n    assert updated_product[\"name\"] == product_data[\"name\"]  # Should remain unchanged\n    assert updated_product[\"description\"] == product_data[\"description\"]  # Should remain unchanged\n    assert updated_product[\"price\"] == partial_update_data[\"price\"]\n    assert updated_product[\"stock_quantity\"] == partial_update_data[\"stock_quantity\"]\n\n    # Verify by fetching again\n    get_response = client.get(f\"/products/{product_id}\")\n    verified_product = json.loads(get_response.data)\n    assert verified_product[\"price\"] == partial_update_data[\"price\"]\n    assert verified_product[\"stock_quantity\"] == partial_update_data[\"stock_quantity\"]\n    assert verified_product[\"name\"] == product_data[\"name\"]\n\n\ndef test_update_product_not_found(client):\n    \"\"\"\n    Tests updating a non-existent product.\n    \"\"\"\n    non_existent_id = str(uuid.uuid4())\n    update_data = {\"name\": \"Non Existent Update\"}\n    response = client.put(f\"/products/{non_existent_id}\", json=update_data)\n    assert response.status_code == 404\n    assert \"error\" in json.loads(response.data)\n\n\ndef test_update_product_invalid_data(client):\n    \"\"\"\n    Tests updating a product with invalid data types.\n    \"\"\"\n    product_data = {\n        \"name\": \"Original Product\",\n        \"description\": \"Original description.\",\n        \"price\": 10.0,\n        \"stock_quantity\": 10\n    }\n    post_response = client.post(\"/products\", json=product_data)\n    created_product = json.loads(post_response.data)\n    product_id = created_product[\"id\"]\n\n    invalid_update_data = {\n        \"price\": \"invalid_price_type\"\n    }\n    response = client.put(f\"/products/{product_id}\", json=invalid_update_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n\ndef test_delete_product_success(client):\n    \"\"\"\n    Tests successful deletion of a product.\n    \"\"\"\n    product_data = {\n        \"name\": \"Product to Delete\",\n        \"description\": \"This product will be deleted.\",\n        \"price\": 1.0,\n        \"stock_quantity\": 1\n    }\n    post_response = client.post(\"/products\", json=product_data)\n    created_product = json.loads(post_response.data)\n    product_id = created_product[\"id\"]\n\n    delete_response = client.delete(f\"/products/{product_id}\")\n    data = json.loads(delete_response.data)\n\n    assert delete_response.status_code == 200\n    assert \"message\" in data\n    assert data[\"message\"] == \"Product deleted successfully\"\n\n    # Verify deletion by trying to retrieve the product\n    get_response = client.get(f\"/products/{product_id}\")\n    assert get_response.status_code == 404\n\n\ndef test_delete_product_not_found(client):\n    \"\"\"\n    Tests deleting a non-existent product.\n    \"\"\"\n    non_existent_id = str(uuid.uuid4())\n    response = client.delete(f\"/products/{non_existent_id}\")\n    assert response.status_code == 404\n    assert \"error\" in json.loads(response.data)"
    },
    "code_quality_feedback": "Dependency installation failed: ERROR: Invalid requirement: 'Flask-RESTful (optional, for simpler API development)' (from line 2 of requirements.txt)\n\n[notice] A new release of pip is available: 23.2.1 -> 25.1.1\n[notice] To update, run: python.exe -m pip install --upgrade pip\n. Generated code cannot run.",
    "test_results_feedback": "",
    "generated_app_root_path": "C:\\d drive\\Anurag\\L&T\\multi_ai_dev_system\\output\\project_run_20250523154156",
    "generated_code_files": {
        "README.md": "## Product Management API\n\nThis is a simple RESTful API for managing product information, built with Python and Flask, using SQLite for data persistence.",
        "requirements.txt": "Flask\nFlask-RESTful (optional, for simpler API development)\nFlask-SQLAlchemy (optional, for ORM)\nSQLAlchemy (if not using Flask-SQLAlchemy)\npython-dotenv (for environment variables)",
        ".gitignore": "# Python\n__pycache__/\n*.pyc\n.pytest_cache/\n.venv/\nenv/\ninstance/\n\n# Database\n*.db\n*.sqlite3",
        "run.py": "from app import app\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "instance/app.db": "# SQLite database file. This file will be created and managed by the application.",
        "app/__init__.py": "import os\nfrom flask import Flask\n\ndef create_app():\n    \"\"\"\n    Creates and configures the Flask application instance.\n\n    This function sets up the Flask application, including:\n    - Creating the application instance with instance-relative configuration.\n    - Ensuring the instance folder exists for storing database files.\n    - Configuring the SQLite database path.\n    - Initializing the database connection and schema.\n    - Registering the product management blueprint for API routes.\n    \"\"\"\n    app = Flask(__name__, instance_relative_config=True)\n\n    # Ensure the instance folder exists\n    # This folder is used to store the SQLite database file.\n    try:\n        os.makedirs(app.instance_path, exist_ok=True)\n    except OSError:\n        # In a production environment, more robust error handling might be needed here,\n        # e.g., logging the error or raising a specific exception.\n        # For this simple application, exist_ok=True handles most cases.\n        pass\n\n    # Configure the database path\n    # The database file will be located in the 'instance' folder.\n    app.config.from_mapping(\n        DATABASE=os.path.join(app.instance_path, 'products.sqlite'),\n    )\n\n    # Initialize the database\n    # This imports the db module and calls its init_app function\n    # to register database-related commands and teardown functions.\n    from . import db\n    db.init_app(app)\n\n    # Register blueprints\n    # This imports the products blueprint and registers it with the app.\n    # All routes defined in the products blueprint will be accessible.\n    from . import products\n    app.register_blueprint(products.bp)\n\n    # A simple test route to verify the app is running\n    @app.route('/hello')\n    def hello():\n        return 'Hello, World!'\n\n    return app",
        "app/config.py": "import os\n\n# Determine the base directory of the application.\n# This assumes config.py is located in the 'app' directory,\n# and the database file will be one level up (in the project root).\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\nclass Config:\n    \"\"\"Base configuration class with common settings.\"\"\"\n    # A secret key is essential for Flask applications for session management,\n    # CSRF protection, etc. For development, a hardcoded key is used as a fallback.\n    # In a production environment, SECRET_KEY MUST be set via environment variables\n    # and should be a strong, randomly generated string.\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'a_very_secret_key_for_development_and_testing_only'\n\n    # Database configuration for SQLite\n    DATABASE_NAME = 'products.db'\n    # The database file will be located in the project root directory.\n    DATABASE_PATH = os.path.join(basedir, '..', DATABASE_NAME)\n\nclass DevelopmentConfig(Config):\n    \"\"\"Development specific configuration.\"\"\"\n    DEBUG = True\n    # For development, we use the default database path defined in Config.\n    # If a separate development database file was desired, it could be overridden here.\n    # Example: DATABASE_NAME = 'products_dev.db'\n    #          DATABASE_PATH = os.path.join(basedir, '..', DATABASE_NAME)\n\nclass TestingConfig(Config):\n    \"\"\"Testing specific configuration.\"\"\"\n    TESTING = True\n    DEBUG = True  # Often useful to see full tracebacks during testing.\n    # Use an in-memory SQLite database for testing for isolation and speed.\n    # This means the database is created in RAM and cleared after the application stops.\n    DATABASE_NAME = ':memory:' # Special name for in-memory SQLite\n    DATABASE_PATH = DATABASE_NAME # Path is just the special name for in-memory\n\nclass ProductionConfig(Config):\n    \"\"\"Production specific configuration.\"\"\"\n    DEBUG = False\n    TESTING = False\n    # In production, SECRET_KEY should always be provided via environment variables.\n    # The base Config provides a fallback, but for a real production system,\n    # it's critical to ensure this is set externally.\n    # For this MVP, the fallback is acceptable as per the simplicity NFR.",
        "app/db.py": "import sqlite3\nimport uuid\n\nimport click\nfrom flask import current_app, g\nfrom flask.cli import with_appcontext\n\n\ndef get_db():\n    \"\"\"\n    Establishes a database connection or returns the existing one for the current request.\n    The connection is stored in Flask's `g` object to ensure it's reused within the same request.\n    `sqlite3.Row` is used as the row factory to allow dictionary-like access to query results.\n    \"\"\"\n    if 'db' not in g:\n        g.db = sqlite3.connect(\n            current_app.config['DATABASE'],\n            detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n    return g.db\n\n\ndef close_db(e=None):\n    \"\"\"\n    Closes the database connection if it exists in Flask's `g` object.\n    This function is registered as a teardown function for the Flask application context,\n    ensuring the database connection is closed at the end of each request.\n    \"\"\"\n    db = g.pop('db', None)\n    if db is not None:\n        db.close()\n\n\ndef init_db():\n    \"\"\"\n    Initializes the database by executing the schema.sql script.\n    This creates the necessary tables (e.g., 'products') if they don't exist.\n    \"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql') as f:\n        db.executescript(f.read().decode('utf8'))\n\n\n@click.command('init-db')\n@with_appcontext\ndef init_db_command():\n    \"\"\"\n    A Flask CLI command to initialize the database.\n    Usage: `flask init-db`\n    This command will clear any existing data and create new tables based on `schema.sql`.\n    \"\"\"\n    init_db()\n    click.echo('Initialized the database.')\n\n\ndef init_app(app):\n    \"\"\"\n    Registers database-related functions with the Flask application instance.\n    - `close_db` is registered as a teardown function.\n    - `init_db_command` is added to the Flask CLI.\n    \"\"\"\n    app.teardown_appcontext(close_db)\n    app.cli.add_command(init_db_command)\n\n\n# --- CRUD Operations for Products ---\n\ndef create_product(name, description, price, stock_quantity):\n    \"\"\"\n    Inserts a new product into the database.\n    A unique ID (UUID) is automatically generated for the product.\n    Returns the dictionary representation of the newly created product.\n    \"\"\"\n    db = get_db()\n    product_id = str(uuid.uuid4())\n    cursor = db.cursor()\n    cursor.execute(\n        \"INSERT INTO products (id, name, description, price, stock_quantity) VALUES (?, ?, ?, ?, ?)\",\n        (product_id, name, description, price, stock_quantity)\n    )\n    db.commit()\n    return {\n        \"id\": product_id,\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"stock_quantity\": stock_quantity\n    }\n\n\ndef get_all_products():\n    \"\"\"\n    Retrieves all products from the database.\n    Returns a list of dictionaries, where each dictionary represents a product.\n    \"\"\"\n    db = get_db()\n    products = db.execute(\n        \"SELECT id, name, description, price, stock_quantity FROM products\"\n    ).fetchall()\n    return [dict(product) for product in products]\n\n\ndef get_product_by_id(product_id):\n    \"\"\"\n    Retrieves a single product by its unique ID.\n    Returns a dictionary representing the product if found, otherwise None.\n    \"\"\"\n    db = get_db()\n    product = db.execute(\n        \"SELECT id, name, description, price, stock_quantity FROM products WHERE id = ?\",\n        (product_id,)\n    ).fetchone()\n    return dict(product) if product else None\n\n\ndef update_product(product_id, data):\n    \"\"\"\n    Updates an existing product's details. Supports partial updates.\n    Only the fields present in the `data` dictionary will be updated.\n    Returns the dictionary representation of the updated product if found, otherwise None.\n    \"\"\"\n    db = get_db()\n    current_product = get_product_by_id(product_id)\n    if not current_product:\n        return None\n\n    set_clauses = []\n    params = []\n    # Iterate through allowed updateable fields and build query dynamically\n    for key, value in data.items():\n        if key in [\"name\", \"description\", \"price\", \"stock_quantity\"]:\n            set_clauses.append(f\"{key} = ?\")\n            params.append(value)\n\n    if not set_clauses:\n        # No valid fields provided for update, return current product state\n        return current_product\n\n    params.append(product_id)  # Add product_id for the WHERE clause\n\n    query = f\"UPDATE products SET {', '.join(set_clauses)} WHERE id = ?\"\n    cursor = db.cursor()\n    cursor.execute(query, tuple(params))\n    db.commit()\n\n    # Fetch and return the updated product to confirm changes\n    return get_product_by_id(product_id)\n\n\ndef delete_product(product_id):\n    \"\"\"\n    Deletes a product from the database by its ID.\n    Returns True if the product was successfully deleted, False if not found.\n    \"\"\"\n    db = get_db()\n    cursor = db.cursor()\n    cursor.execute(\"DELETE FROM products WHERE id = ?\", (product_id,))\n    db.commit()\n    # Check if any row was actually deleted\n    return cursor.rowcount > 0",
        "app/models.py": "from flask_sqlalchemy import SQLAlchemy\nimport uuid\n\ndb = SQLAlchemy()\n\nclass Product(db.Model):\n    \"\"\"\n    Product model representing a product in the inventory.\n    Maps to the 'products' table in the database.\n    \"\"\"\n    __tablename__ = 'products'\n\n    id = db.Column(db.Text, primary_key=True, default=lambda: str(uuid.uuid4()))\n    name = db.Column(db.Text, nullable=False)\n    description = db.Column(db.Text, nullable=True)\n    price = db.Column(db.Float, nullable=False)\n    stock_quantity = db.Column(db.Integer, nullable=False)\n\n    def __repr__(self):\n        \"\"\"\n        Returns a string representation of the Product object.\n        \"\"\"\n        return f\"<Product {self.id}: {self.name}>\"\n\n    def to_dict(self):\n        \"\"\"\n        Converts the Product object to a dictionary, suitable for JSON serialization.\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"price\": self.price,\n            \"stock_quantity\": self.stock_quantity,\n        }",
        "app/routes/__init__.py": "from flask import Flask\nfrom app.database import init_db\nfrom .product_routes import product_bp\n\ndef create_app():\n    \"\"\"\n    Creates and configures the Flask application.\n    This function initializes the database and registers blueprints.\n    \"\"\"\n    app = Flask(__name__)\n\n    # Initialize the database\n    # This ensures the database schema is created when the app starts.\n    # It's good practice to do this within an application context.\n    with app.app_context():\n        init_db()\n\n    # Register blueprints\n    # The product_bp blueprint will handle all product-related API endpoints.\n    app.register_blueprint(product_bp)\n\n    return app",
        "app/routes/products.py": "import sqlite3\nimport uuid\nfrom flask import Blueprint, request, jsonify, g, current_app\n\n# Create a Blueprint for product routes\nproducts_bp = Blueprint('products', __name__, url_prefix='/products')\n\n# Define the database path. In a larger app, this would be in a config file.\nDATABASE = 'database.db'\n\ndef get_db():\n    \"\"\"\n    Establishes a database connection if one is not already present for the current request.\n    The connection is stored in Flask's `g` object.\n    \"\"\"\n    if 'db' not in g:\n        g.db = sqlite3.connect(\n            DATABASE,\n            detect_types=sqlite3.PARSE_DECLTYPES # This helps with type conversion for dates/times if used\n        )\n        g.db.row_factory = sqlite3.Row # This allows accessing columns by name\n    return g.db\n\n@products_bp.teardown_request\ndef close_db(exception):\n    \"\"\"\n    Closes the database connection at the end of the request.\n    This function is registered with the blueprint's teardown_request.\n    \"\"\"\n    db = g.pop('db', None)\n    if db is not None:\n        db.close()\n\ndef row_to_dict(row):\n    \"\"\"\n    Converts a sqlite3.Row object to a standard Python dictionary.\n    This is useful for jsonify responses.\n    \"\"\"\n    return dict(row)\n\n@products_bp.route('/', methods=['POST'])\ndef create_product():\n    \"\"\"\n    API endpoint to create a new product.\n    Requires 'name', 'price', 'stock_quantity' in the JSON request body.\n    'description' is optional.\n    Returns the newly created product with a 201 status code on success.\n    Handles 400 Bad Request for invalid input.\n    \"\"\"\n    data = request.get_json()\n\n    if not data:\n        return jsonify({\"error\": \"Request must be JSON\"}), 400\n\n    name = data.get('name')\n    price = data.get('price')\n    stock_quantity = data.get('stock_quantity')\n    description = data.get('description')\n\n    # Validate required fields\n    if not name or not isinstance(name, str):\n        return jsonify({\"error\": \"Product name (string) is required\"}), 400\n    if price is None:\n        return jsonify({\"error\": \"Product price is required\"}), 400\n    if stock_quantity is None:\n        return jsonify({\"error\": \"Product stock_quantity is required\"}), 400\n\n    # Validate data types and constraints\n    try:\n        price = float(price)\n        if price < 0:\n            return jsonify({\"error\": \"Price must be a non-negative number\"}), 400\n    except (ValueError, TypeError):\n        return jsonify({\"error\": \"Price must be a valid number\"}), 400\n\n    try:\n        stock_quantity = int(stock_quantity)\n        if stock_quantity < 0:\n            return jsonify({\"error\": \"Stock quantity must be a non-negative integer\"}), 400\n    except (ValueError, TypeError):\n        return jsonify({\"error\": \"Stock quantity must be a valid integer\"}), 400\n\n    if description is not None and not isinstance(description, str):\n        return jsonify({\"error\": \"Description must be a string or null\"}), 400\n\n    product_id = str(uuid.uuid4()) # Generate a unique ID\n\n    db = get_db()\n    try:\n        db.execute(\n            \"INSERT INTO products (id, name, description, price, stock_quantity) VALUES (?, ?, ?, ?, ?)\",\n            (product_id, name, description, price, stock_quantity)\n        )\n        db.commit()\n    except sqlite3.Error as e:\n        current_app.logger.error(f\"Database error during product creation: {e}\")\n        return jsonify({\"error\": \"Failed to create product due to database error\"}), 500\n\n    new_product = {\n        \"id\": product_id,\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"stock_quantity\": stock_quantity\n    }\n    return jsonify(new_product), 201\n\n@products_bp.route('/', methods=['GET'])\ndef get_all_products():\n    \"\"\"\n    API endpoint to retrieve a list of all products.\n    Returns a JSON array of product objects.\n    \"\"\"\n    db = get_db()\n    products = db.execute(\"SELECT * FROM products\").fetchall()\n    return jsonify([row_to_dict(product) for product in products]), 200\n\n@products_bp.route('/<string:product_id>', methods=['GET'])\ndef get_product_by_id(product_id):\n    \"\"\"\n    API endpoint to retrieve details for a specific product by its ID.\n    Returns the product object if found, or 404 Not Found.\n    \"\"\"\n    db = get_db()\n    product = db.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,)).fetchone()\n\n    if product is None:\n        return jsonify({\"error\": \"Product not found\"}), 404\n    return jsonify(row_to_dict(product)), 200\n\n@products_bp.route('/<string:product_id>', methods=['PUT'])\ndef update_product(product_id):\n    \"\"\"\n    API endpoint to update an existing product's details.\n    Supports partial updates: only fields provided in the JSON body will be updated.\n    Returns the updated product object if successful, or 404 Not Found/400 Bad Request.\n    \"\"\"\n    data = request.get_json()\n\n    if not data:\n        return jsonify({\"error\": \"Request must be JSON\"}), 400\n\n    db = get_db()\n    product = db.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,)).fetchone()\n\n    if product is None:\n        return jsonify({\"error\": \"Product not found\"}), 404\n\n    # Convert product row to dict for easier modification and to build the response\n    updated_product_data = row_to_dict(product)\n\n    # Prepare for dynamic update query\n    update_fields = []\n    update_values = []\n\n    # Check and update fields if provided in the request body\n    if 'name' in data:\n        if not isinstance(data['name'], str) or not data['name']:\n            return jsonify({\"error\": \"Name must be a non-empty string\"}), 400\n        update_fields.append(\"name = ?\")\n        update_values.append(data['name'])\n        updated_product_data['name'] = data['name']\n\n    if 'description' in data:\n        # Description can be null, so check for string or None\n        if not isinstance(data['description'], (str, type(None))):\n            return jsonify({\"error\": \"Description must be a string or null\"}), 400\n        update_fields.append(\"description = ?\")\n        update_values.append(data['description'])\n        updated_product_data['description'] = data['description']\n\n    if 'price' in data:\n        try:\n            price = float(data['price'])\n            if price < 0:\n                return jsonify({\"error\": \"Price must be a non-negative number\"}), 400\n            update_fields.append(\"price = ?\")\n            update_values.append(price)\n            updated_product_data['price'] = price\n        except (ValueError, TypeError):\n            return jsonify({\"error\": \"Price must be a valid number\"}), 400\n\n    if 'stock_quantity' in data:\n        try:\n            stock_quantity = int(data['stock_quantity'])\n            if stock_quantity < 0:\n                return jsonify({\"error\": \"Stock quantity must be a non-negative integer\"}), 400\n            update_fields.append(\"stock_quantity = ?\")\n            update_values.append(stock_quantity)\n            updated_product_data['stock_quantity'] = stock_quantity\n        except (ValueError, TypeError):\n            return jsonify({\"error\": \"Stock quantity must be a valid integer\"}), 400\n\n    # If no valid fields were provided for update, return 200 with current data\n    if not update_fields:\n        return jsonify({\"message\": \"No valid fields provided for update, product remains unchanged\",\n                        \"product\": updated_product_data}), 200\n\n    update_query = \"UPDATE products SET \" + \", \".join(update_fields) + \" WHERE id = ?\"\n    update_values.append(product_id)\n\n    try:\n        db.execute(update_query, tuple(update_values))\n        db.commit()\n    except sqlite3.Error as e:\n        current_app.logger.error(f\"Database error during product update: {e}\")\n        return jsonify({\"error\": \"Failed to update product due to database error\"}), 500\n\n    return jsonify(updated_product_data), 200\n\n@products_bp.route('/<string:product_id>', methods=['DELETE'])\ndef delete_product(product_id):\n    \"\"\"\n    API endpoint to remove a product from the system by its ID.\n    Returns a success message with 200 status, or 404 Not Found.\n    \"\"\"\n    db = get_db()\n    cursor = db.execute(\"DELETE FROM products WHERE id = ?\", (product_id,))\n    db.commit()\n\n    if cursor.rowcount == 0:\n        return jsonify({\"error\": \"Product not found\"}), 404\n    return jsonify({\"message\": \"Product deleted successfully\"}), 200",
        "app/utils.py": "import sqlite3\nimport uuid\nimport os\n\nDATABASE = 'database.db'\n\ndef get_db_connection():\n    \"\"\"\n    Establishes a connection to the SQLite database.\n    Sets row_factory to sqlite3.Row to allow dictionary-like access to rows.\n    \"\"\"\n    conn = sqlite3.connect(DATABASE)\n    conn.row_factory = sqlite3.Row\n    return conn\n\ndef init_db():\n    \"\"\"\n    Initializes the database by creating the 'products' table if it doesn't exist.\n    This function should be called once, typically at application startup.\n    \"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS products (\n            id TEXT PRIMARY KEY,\n            name TEXT NOT NULL,\n            description TEXT,\n            price REAL NOT NULL,\n            stock_quantity INTEGER NOT NULL\n        );\n    \"\"\")\n    conn.commit()\n    conn.close()\n\ndef generate_uuid():\n    \"\"\"\n    Generates a unique identifier (UUID) for product IDs.\n    \"\"\"\n    return str(uuid.uuid4())\n\ndef validate_product_data(data, is_update=False):\n    \"\"\"\n    Validates product data for creation or update.\n\n    Args:\n        data (dict): The dictionary containing product data.\n        is_update (bool): True if validating for an update (allows partial data), False for creation.\n\n    Returns:\n        tuple: A tuple containing (is_valid, error_message).\n    \"\"\"\n    required_fields = ['name', 'price', 'stock_quantity']\n    errors = []\n\n    if not is_update:\n        for field in required_fields:\n            if field not in data:\n                errors.append(f\"Missing required field: '{field}'\")\n    \n    if 'name' in data and not isinstance(data['name'], str):\n        errors.append(\"Name must be a string.\")\n    elif 'name' in data and not data['name'].strip():\n        errors.append(\"Name cannot be empty.\")\n\n    if 'description' in data and not isinstance(data['description'], str):\n        errors.append(\"Description must be a string.\")\n\n    if 'price' in data:\n        try:\n            price = float(data['price'])\n            if price <= 0:\n                errors.append(\"Price must be a positive number.\")\n        except (ValueError, TypeError):\n            errors.append(\"Price must be a valid number.\")\n\n    if 'stock_quantity' in data:\n        try:\n            stock_quantity = int(data['stock_quantity'])\n            if stock_quantity < 0:\n                errors.append(\"Stock quantity cannot be negative.\")\n        except (ValueError, TypeError):\n            errors.append(\"Stock quantity must be a valid integer.\")\n\n    if errors:\n        return False, \", \".join(errors)\n    return True, None\n\n# Ensure the database directory exists if needed (though for single file, not strictly necessary)\n# if not os.path.exists(os.path.dirname(DATABASE)):\n#     os.makedirs(os.path.dirname(DATABASE))\n\n# Call init_db() when this module is imported to ensure the table exists\n# This is a common pattern for simple Flask apps with SQLite.\ninit_db()",
        "app/errors.py": "from flask import jsonify\nfrom werkzeug.exceptions import HTTPException\n\nclass APIError(HTTPException):\n    \"\"\"\n    Custom exception class for API errors.\n    Inherits from HTTPException to allow Flask's error handling mechanism\n    to automatically catch and process it, returning a JSON response.\n    \"\"\"\n    def __init__(self, message, status_code):\n        # HTTPException constructor takes description and optionally response\n        super().__init__(description=message)\n        self.code = status_code  # Set the HTTP status code for this exception\n\n    def get_body(self, environ=None):\n        \"\"\"\n        Overrides get_body to return the JSON error message.\n        \"\"\"\n        return jsonify({\"message\": self.description}).get_data(as_text=True)\n\n    def get_headers(self, environ=None):\n        \"\"\"\n        Overrides get_headers to ensure Content-Type is application/json.\n        \"\"\"\n        return [('Content-Type', 'application/json')]\n\ndef register_error_handlers(app):\n    \"\"\"\n    Registers custom error handlers with the Flask application.\n    \"\"\"\n\n    @app.errorhandler(APIError)\n    def handle_api_error(error):\n        \"\"\"\n        Handler for custom APIError exceptions.\n        Since APIError inherits from HTTPException, Flask will automatically\n        call its get_response method. We can simply return the error object.\n        \"\"\"\n        return error\n\n    @app.errorhandler(404)\n    def handle_not_found_error(error):\n        \"\"\"\n        Handler for 404 Not Found errors.\n        Returns a JSON response for consistency.\n        \"\"\"\n        response = jsonify({\"message\": \"Resource not found\"})\n        response.status_code = 404\n        return response\n\n    @app.errorhandler(400)\n    def handle_bad_request_error(error):\n        \"\"\"\n        Handler for 400 Bad Request errors.\n        This can catch errors from Flask's request parsing (e.g., malformed JSON,\n        missing required fields if handled by Flask's default parsers).\n        Returns a JSON response.\n        \"\"\"\n        # Werkzeug's BadRequest (which is a 400 HTTPException) has a description.\n        # Use it if available, otherwise a generic message.\n        message = getattr(error, 'description', 'Bad request')\n        response = jsonify({\"message\": message})\n        response.status_code = 400\n        return response\n\n    @app.errorhandler(500)\n    def handle_internal_server_error(error):\n        \"\"\"\n        Handler for 500 Internal Server Error.\n        Catches unhandled exceptions that result in a 500.\n        Returns a JSON response.\n        \"\"\"\n        response = jsonify({\"message\": \"An unexpected error occurred.\"})\n        response.status_code = 500\n        return response\n\n    @app.errorhandler(Exception)\n    def handle_generic_exception(e):\n        \"\"\"\n        Catch-all handler for any other unhandled exceptions.\n        This ensures all errors return a consistent JSON format, even for\n        unexpected server errors.\n        \"\"\"\n        # Log the exception for debugging purposes\n        app.logger.error(f\"Unhandled exception: {e}\", exc_info=True)\n        response = jsonify({\"message\": \"An unexpected error occurred.\"})\n        response.status_code = 500\n        return response",
        "tests/__init__.py": "\"\"\"\nInitializes the 'tests' Python package.\n\"\"\"",
        "tests/conftest.py": "import pytest\nfrom src.app import create_app, init_db\n\n@pytest.fixture\ndef app():\n    \"\"\"Create and configure a new app instance for each test.\"\"\"\n    app = create_app({\n        'TESTING': True,\n        'DATABASE': ':memory:',  # Use in-memory SQLite for tests\n    })\n\n    with app.app_context():\n        # Initialize the database schema for the test database.\n        # This calls the init_db function from src/app.py,\n        # which should execute the schema creation SQL.\n        init_db()\n\n    yield app\n\n@pytest.fixture\ndef client(app):\n    \"\"\"A test client for the app.\"\"\"\n    return app.test_client()\n\n@pytest.fixture\ndef runner(app):\n    \"\"\"A test CLI runner for the app.\"\"\"\n    return app.test_cli_runner()",
        "tests/test_products_api.py": "import pytest\nimport json\nimport uuid\n\n# Assuming the Flask app and database initialization functions are in 'app.py'\n# We need to import them to set up the test environment.\n# The 'app' module should expose a function like 'create_app'\n# and a function like 'init_db' that sets up the database schema.\nfrom app import create_app, init_db\n\n\n@pytest.fixture\ndef client():\n    \"\"\"\n    Configures the Flask app for testing, sets up an in-memory SQLite database,\n    initializes the database schema, and provides a test client.\n    \"\"\"\n    app = create_app()\n    app.config['TESTING'] = True\n    # Use an in-memory SQLite database for testing\n    app.config['DATABASE'] = ':memory:'\n\n    with app.test_client() as client:\n        # Push an application context to initialize the database\n        with app.app_context():\n            init_db()\n        yield client\n\n\ndef test_create_product_success(client):\n    \"\"\"\n    Tests successful creation of a new product.\n    \"\"\"\n    product_data = {\n        \"name\": \"Test Product\",\n        \"description\": \"A product for testing purposes.\",\n        \"price\": 99.99,\n        \"stock_quantity\": 10\n    }\n    response = client.post(\"/products\", json=product_data)\n    data = json.loads(response.data)\n\n    assert response.status_code == 201\n    assert \"id\" in data\n    assert data[\"name\"] == product_data[\"name\"]\n    assert data[\"description\"] == product_data[\"description\"]\n    assert data[\"price\"] == product_data[\"price\"]\n    assert data[\"stock_quantity\"] == product_data[\"stock_quantity\"]\n\n\ndef test_create_product_missing_required_fields(client):\n    \"\"\"\n    Tests creating a product with missing required fields.\n    \"\"\"\n    # Missing 'name'\n    product_data = {\n        \"description\": \"A product for testing purposes.\",\n        \"price\": 99.99,\n        \"stock_quantity\": 10\n    }\n    response = client.post(\"/products\", json=product_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n    # Missing 'price'\n    product_data = {\n        \"name\": \"Test Product\",\n        \"description\": \"A product for testing purposes.\",\n        \"stock_quantity\": 10\n    }\n    response = client.post(\"/products\", json=product_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n    # Missing 'stock_quantity'\n    product_data = {\n        \"name\": \"Test Product\",\n        \"description\": \"A product for testing purposes.\",\n        \"price\": 99.99\n    }\n    response = client.post(\"/products\", json=product_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n\ndef test_create_product_invalid_data_types(client):\n    \"\"\"\n    Tests creating a product with invalid data types for fields.\n    \"\"\"\n    product_data = {\n        \"name\": \"Test Product\",\n        \"description\": \"A product for testing purposes.\",\n        \"price\": \"invalid_price\",  # Invalid type\n        \"stock_quantity\": 10\n    }\n    response = client.post(\"/products\", json=product_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n    product_data = {\n        \"name\": \"Test Product\",\n        \"description\": \"A product for testing purposes.\",\n        \"price\": 99.99,\n        \"stock_quantity\": \"invalid_stock\"  # Invalid type\n    }\n    response = client.post(\"/products\", json=product_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n\ndef test_get_all_products_empty(client):\n    \"\"\"\n    Tests retrieving all products when no products exist.\n    \"\"\"\n    response = client.get(\"/products\")\n    data = json.loads(response.data)\n\n    assert response.status_code == 200\n    assert isinstance(data, list)\n    assert len(data) == 0\n\n\ndef test_get_all_products_with_data(client):\n    \"\"\"\n    Tests retrieving all products when products exist.\n    \"\"\"\n    product1_data = {\n        \"name\": \"Product A\",\n        \"description\": \"Desc A\",\n        \"price\": 10.0,\n        \"stock_quantity\": 100\n    }\n    product2_data = {\n        \"name\": \"Product B\",\n        \"description\": \"Desc B\",\n        \"price\": 20.0,\n        \"stock_quantity\": 200\n    }\n    client.post(\"/products\", json=product1_data)\n    client.post(\"/products\", json=product2_data)\n\n    response = client.get(\"/products\")\n    data = json.loads(response.data)\n\n    assert response.status_code == 200\n    assert isinstance(data, list)\n    assert len(data) == 2\n    # Check if the names are present in the returned list\n    assert any(p[\"name\"] == \"Product A\" for p in data)\n    assert any(p[\"name\"] == \"Product B\" for p in data)\n\n\ndef test_get_product_by_id_success(client):\n    \"\"\"\n    Tests retrieving a specific product by its ID successfully.\n    \"\"\"\n    product_data = {\n        \"name\": \"Unique Product\",\n        \"description\": \"Description for unique product.\",\n        \"price\": 50.0,\n        \"stock_quantity\": 5\n    }\n    post_response = client.post(\"/products\", json=product_data)\n    created_product = json.loads(post_response.data)\n    product_id = created_product[\"id\"]\n\n    get_response = client.get(f\"/products/{product_id}\")\n    retrieved_product = json.loads(get_response.data)\n\n    assert get_response.status_code == 200\n    assert retrieved_product[\"id\"] == product_id\n    assert retrieved_product[\"name\"] == product_data[\"name\"]\n    assert retrieved_product[\"price\"] == product_data[\"price\"]\n\n\ndef test_get_product_by_id_not_found(client):\n    \"\"\"\n    Tests retrieving a product with a non-existent ID.\n    \"\"\"\n    non_existent_id = str(uuid.uuid4())  # Generate a valid-looking but non-existent UUID\n    response = client.get(f\"/products/{non_existent_id}\")\n    assert response.status_code == 404\n    assert \"error\" in json.loads(response.data)\n\n\ndef test_update_product_full_success(client):\n    \"\"\"\n    Tests full update of an existing product.\n    \"\"\"\n    product_data = {\n        \"name\": \"Original Product\",\n        \"description\": \"Original description.\",\n        \"price\": 10.0,\n        \"stock_quantity\": 10\n    }\n    post_response = client.post(\"/products\", json=product_data)\n    created_product = json.loads(post_response.data)\n    product_id = created_product[\"id\"]\n\n    updated_data = {\n        \"name\": \"Updated Product\",\n        \"description\": \"New description.\",\n        \"price\": 15.0,\n        \"stock_quantity\": 15\n    }\n    put_response = client.put(f\"/products/{product_id}\", json=updated_data)\n    updated_product = json.loads(put_response.data)\n\n    assert put_response.status_code == 200\n    assert updated_product[\"id\"] == product_id\n    assert updated_product[\"name\"] == updated_data[\"name\"]\n    assert updated_product[\"description\"] == updated_data[\"description\"]\n    assert updated_product[\"price\"] == updated_data[\"price\"]\n    assert updated_product[\"stock_quantity\"] == updated_data[\"stock_quantity\"]\n\n    # Verify by fetching again\n    get_response = client.get(f\"/products/{product_id}\")\n    verified_product = json.loads(get_response.data)\n    assert verified_product[\"name\"] == updated_data[\"name\"]\n\n\ndef test_update_product_partial_success(client):\n    \"\"\"\n    Tests partial update of an existing product.\n    \"\"\"\n    product_data = {\n        \"name\": \"Original Product\",\n        \"description\": \"Original description.\",\n        \"price\": 10.0,\n        \"stock_quantity\": 10\n    }\n    post_response = client.post(\"/products\", json=product_data)\n    created_product = json.loads(post_response.data)\n    product_id = created_product[\"id\"]\n\n    partial_update_data = {\n        \"price\": 12.5,\n        \"stock_quantity\": 8\n    }\n    put_response = client.put(f\"/products/{product_id}\", json=partial_update_data)\n    updated_product = json.loads(put_response.data)\n\n    assert put_response.status_code == 200\n    assert updated_product[\"id\"] == product_id\n    assert updated_product[\"name\"] == product_data[\"name\"]  # Should remain unchanged\n    assert updated_product[\"description\"] == product_data[\"description\"]  # Should remain unchanged\n    assert updated_product[\"price\"] == partial_update_data[\"price\"]\n    assert updated_product[\"stock_quantity\"] == partial_update_data[\"stock_quantity\"]\n\n    # Verify by fetching again\n    get_response = client.get(f\"/products/{product_id}\")\n    verified_product = json.loads(get_response.data)\n    assert verified_product[\"price\"] == partial_update_data[\"price\"]\n    assert verified_product[\"stock_quantity\"] == partial_update_data[\"stock_quantity\"]\n    assert verified_product[\"name\"] == product_data[\"name\"]\n\n\ndef test_update_product_not_found(client):\n    \"\"\"\n    Tests updating a non-existent product.\n    \"\"\"\n    non_existent_id = str(uuid.uuid4())\n    update_data = {\"name\": \"Non Existent Update\"}\n    response = client.put(f\"/products/{non_existent_id}\", json=update_data)\n    assert response.status_code == 404\n    assert \"error\" in json.loads(response.data)\n\n\ndef test_update_product_invalid_data(client):\n    \"\"\"\n    Tests updating a product with invalid data types.\n    \"\"\"\n    product_data = {\n        \"name\": \"Original Product\",\n        \"description\": \"Original description.\",\n        \"price\": 10.0,\n        \"stock_quantity\": 10\n    }\n    post_response = client.post(\"/products\", json=product_data)\n    created_product = json.loads(post_response.data)\n    product_id = created_product[\"id\"]\n\n    invalid_update_data = {\n        \"price\": \"invalid_price_type\"\n    }\n    response = client.put(f\"/products/{product_id}\", json=invalid_update_data)\n    assert response.status_code == 400\n    assert \"error\" in json.loads(response.data)\n\n\ndef test_delete_product_success(client):\n    \"\"\"\n    Tests successful deletion of a product.\n    \"\"\"\n    product_data = {\n        \"name\": \"Product to Delete\",\n        \"description\": \"This product will be deleted.\",\n        \"price\": 1.0,\n        \"stock_quantity\": 1\n    }\n    post_response = client.post(\"/products\", json=product_data)\n    created_product = json.loads(post_response.data)\n    product_id = created_product[\"id\"]\n\n    delete_response = client.delete(f\"/products/{product_id}\")\n    data = json.loads(delete_response.data)\n\n    assert delete_response.status_code == 200\n    assert \"message\" in data\n    assert data[\"message\"] == \"Product deleted successfully\"\n\n    # Verify deletion by trying to retrieve the product\n    get_response = client.get(f\"/products/{product_id}\")\n    assert get_response.status_code == 404\n\n\ndef test_delete_product_not_found(client):\n    \"\"\"\n    Tests deleting a non-existent product.\n    \"\"\"\n    non_existent_id = str(uuid.uuid4())\n    response = client.delete(f\"/products/{non_existent_id}\")\n    assert response.status_code == 404\n    assert \"error\" in json.loads(response.data)"
    },
    "code_quality_report": {
        "summary": "The static analysis report indicates a high volume of style and formatting issues across the project, primarily related to PEP 8 guidelines. While no critical syntax errors, unhandled exceptions, or obvious security flaws were detected by the linter, the sheer number of minor style violations suggests a lack of consistent code formatting and adherence to best practices. This can significantly impact code readability and maintainability.",
        "has_critical_issues": true,
        "details": [
            {
                "type": "Linting (Style)",
                "issue": "Inconsistent blank lines (E302, E305) before/after functions, classes, and other code blocks.",
                "severity": "Minor"
            },
            {
                "type": "Linting (Style)",
                "issue": "Numerous lines exceeding the recommended maximum character limit (E501).",
                "severity": "Minor"
            },
            {
                "type": "Linting (Style)",
                "issue": "Missing newlines at the end of several files (W292).",
                "severity": "Cosmetic"
            },
            {
                "type": "Linting (Style)",
                "issue": "Blank lines containing unnecessary whitespace (W293).",
                "severity": "Cosmetic"
            },
            {
                "type": "Linting (Style)",
                "issue": "Incorrect spacing before inline comments (E261).",
                "severity": "Cosmetic"
            },
            {
                "type": "Linting (Code Quality)",
                "issue": "One unused import detected ('sqlite3' in tests/conftest.py - F401).",
                "severity": "Minor"
            },
            {
                "type": "Linting",
                "issue": "Linting errors detected (see raw output in memory).",
                "severity": "Critical"
            }
        ],
        "recommendations": [
            "Adopt and enforce a consistent code style guide, such as PEP 8, across the entire project.",
            "Integrate an automated code formatter (e.g., Black, autopep8) into the development workflow to automatically fix most style issues.",
            "Configure and run a linter (e.g., Flake8) as part of pre-commit hooks or CI/CD pipelines to catch style and minor code quality issues early.",
            "Address all reported linting issues, prioritizing the most frequent ones (E302, E501) to significantly improve code readability.",
            "Review and remove any unused imports to keep the codebase clean and efficient.",
            "Review and fix linting errors for code style and potential bugs."
        ]
    }
}