{
    "raw_brd": "# Simple CRUD API for Products\n\n## 1. Introduction\n\nThis document outlines the requirements for a simple RESTful API to manage product information. The API should allow users to create, read, update, and delete product entries.\n\n## 2. Functional Requirements\n\n- **FR1: Create Product:**\n  - Users must be able to add a new product to the system.\n  - A product must have a `name` (string), `description` (string, optional), `price` (float), and `stock_quantity` (integer).\n  - A unique ID should be automatically generated for each product.\n- **FR2: Get All Products:**\n  - Users must be able to retrieve a list of all products.\n  - The list should include all product details (ID, name, description, price, stock_quantity).\n- **FR3: Get Product by ID:**\n  - Users must be able to retrieve details for a specific product using its unique ID.\n- **FR4: Update Product:**\n  - Users must be able to modify an existing product's details (name, description, price, stock_quantity) using its ID.\n  - Partial updates (e.g., updating only the price) should be supported.\n- **FR5: Delete Product:**\n  - Users must be able to remove a product from the system using its ID.\n\n## 3. Non-Functional Requirements\n\n- **NFR1: Performance:** API responses should be fast, ideally within 200ms for common operations.\n- **NFR2: Scalability:** The system should be able to handle up to 100 concurrent requests.\n- **NFR3: Simplicity:** The chosen technology stack should prioritize ease of development and deployment for this initial version.\n- **NFR4: Data Persistence:** Product data must be stored persistently.\n\n## 4. Assumptions\n\n- No user authentication/authorization is required for this initial version.\n- Error handling should be basic (e.g., return 404 for not found, 400 for bad requests).\n- The API will be deployed on a single server.\n",
    "brd_analysis": {
        "summary": "A simple RESTful API to manage product information, enabling users to perform Create, Read, Update, and Delete (CRUD) operations on product entries.",
        "functional_requirements": [
            "FR1: Users must be able to add a new product to the system with a name (string), description (string, optional), price (float), and stock_quantity (integer). A unique ID should be automatically generated.",
            "FR2: Users must be able to retrieve a list of all products, including all product details (ID, name, description, price, stock_quantity).",
            "FR3: Users must be able to retrieve details for a specific product using its unique ID.",
            "FR4: Users must be able to modify an existing product's details (name, description, price, stock_quantity) using its ID, supporting partial updates.",
            "FR5: Users must be able to remove a product from the system using its ID.",
            "non_functional_requirements",
            "NFR1: API responses should be fast, ideally within 200ms for common operations.",
            "NFR2: The system should be able to handle up to 100 concurrent requests.",
            "NFR3: The chosen technology stack should prioritize ease of development and deployment for this initial version.",
            "NFR4: Product data must be stored persistently."
        ],
        "non_functional_requirements": [
            "NFR1: API responses should be fast, ideally within 200ms for common operations.",
            "NFR2: The system should be able to handle up to 100 concurrent requests.",
            "NFR3: The chosen technology stack should prioritize ease of development and deployment for this initial version.",
            "NFR4: Product data must be stored persistently."
        ],
        "user_stories": [
            "As a user, I want to create a new product with a name, optional description, price, and stock quantity so that I can add new items to the system.",
            "As a user, I want to retrieve a list of all products with their details so that I can view the entire product catalog.",
            "As a user, I want to retrieve details for a specific product by its ID so that I can view information about a particular item.",
            "As a user, I want to update an existing product's details, including partial updates, using its ID so that I can correct or modify product information.",
            "As a user, I want to delete a product using its ID so that I can remove obsolete or incorrect items from the system."
        ],
        "assumptions": [
            "No user authentication/authorization is required for this initial version.",
            "Error handling should be basic (e.g., return 404 for not found, 400 for bad requests).",
            "The API will be deployed on a single server."
        ],
        "ambiguities_or_questions": [
            "Question 1: Are there specific constraints for product attributes like maximum length for 'name'/'description', precision for 'price', or non-negative requirements for 'price'/'stock_quantity'?",
            "Question 2: What is the expected format for the automatically generated unique product ID (e.g., UUID, integer sequence)?",
            "Question 3: What specific API endpoints are considered 'common operations' for the 200ms performance target?",
            "Question 4: What is the expected JSON structure for successful responses (e.g., for create, update, or retrieving a single product)?"
        ]
    },
    "tech_stack_recommendation": {
        "frontend": {
            "name": "None",
            "justification": "The project is defined as a RESTful API to manage product information, with no explicit requirement for a user interface in this initial version. The focus is purely on the API endpoints."
        },
        "backend": {
            "name": "Python/Flask",
            "justification": "Flask is a lightweight and flexible micro-framework, ideal for rapid API development and aligns perfectly with NFR3 (ease of development and deployment) for an initial version. Python's clear syntax and extensive libraries further accelerate the development process, while being capable of handling NFR1 (fast responses) and NFR2 (100 concurrent requests) for this scope."
        },
        "database": {
            "name": "SQLite",
            "justification": "SQLite is a file-based, zero-configuration database, making it exceptionally easy to set up and deploy, which directly supports NFR3 (ease of deployment) and the single-server assumption. It ensures NFR4 (data persistence) and is more than capable of handling the simple CRUD operations and performance requirements for this initial version without the overhead of a separate database server."
        },
        "overall_rationale": "This technology stack is specifically chosen to meet the project's primary goal of delivering a simple, fast, and easily deployable RESTful API for product management. Python/Flask provides a highly productive and lightweight backend, perfectly suited for rapid development of the required CRUD operations. SQLite offers a zero-configuration, persistent data store that aligns with the simplicity and single-server deployment assumptions. This combination ensures efficient development, fast API responses, and effective handling of concurrent requests within the specified scope, without introducing unnecessary complexity for an MVP."
    },
    "system_design": {
        "architecture_overview": "A monolithic RESTful API backend service using Python/Flask interacting with a SQLite database, deployed on a single server.",
        "main_modules": [
            "Product Management"
        ],
        "api_endpoints": [
            {
                "path": "/products",
                "method": "POST",
                "description": "Creates a new product with a unique ID.",
                "request_body": {
                    "name": "string",
                    "description": "string",
                    "price": 0.0,
                    "stock_quantity": 0
                },
                "response_example": {
                    "id": "uuid_string",
                    "name": "Example Product",
                    "description": "A brief description.",
                    "price": 19.99,
                    "stock_quantity": 100
                }
            },
            {
                "path": "/products",
                "method": "GET",
                "description": "Retrieves a list of all products.",
                "response_example": [
                    {
                        "id": "uuid_string_1",
                        "name": "Product A",
                        "description": "Description A",
                        "price": 10.5,
                        "stock_quantity": 50
                    },
                    {
                        "id": "uuid_string_2",
                        "name": "Product B",
                        "description": "Description B",
                        "price": 25.0,
                        "stock_quantity": 20
                    }
                ]
            },
            {
                "path": "/products/{id}",
                "method": "GET",
                "description": "Retrieves details for a specific product by its unique ID.",
                "response_example": {
                    "id": "uuid_string",
                    "name": "Specific Product",
                    "description": "Details for a single product.",
                    "price": 99.99,
                    "stock_quantity": 5
                }
            },
            {
                "path": "/products/{id}",
                "method": "PUT",
                "description": "Modifies an existing product's details by ID, supporting partial updates.",
                "request_body": {
                    "name": "string",
                    "description": "string",
                    "price": 0.0,
                    "stock_quantity": 0
                },
                "response_example": {
                    "id": "uuid_string",
                    "name": "Updated Product Name",
                    "description": "Updated description.",
                    "price": 29.99,
                    "stock_quantity": 80
                }
            },
            {
                "path": "/products/{id}",
                "method": "DELETE",
                "description": "Removes a product from the system using its ID.",
                "response_example": {
                    "message": "Product deleted successfully."
                }
            }
        ],
        "database_schema": "CREATE TABLE products (\n    id TEXT PRIMARY KEY,\n    name TEXT NOT NULL,\n    description TEXT,\n    price REAL NOT NULL,\n    stock_quantity INTEGER NOT NULL\n);",
        "design_notes": [
            "Product IDs should be unique identifiers (UUIDs).",
            "Basic error handling should return standard HTTP status codes (e.g., 400 for bad requests, 404 for not found).",
            "No user authentication or authorization is required for this initial MVP version.",
            "The system is designed for single server deployment for simplicity.",
            "API responses should be optimized for speed, aiming for under 200ms for common operations."
        ]
    },
    "generated_codebase_files": {
        "README.md": "## Product Management API\n\nThis is a simple RESTful API for managing product information, built with Python and Flask.",
        "requirements.txt": "Flask\nFlask-SQLAlchemy (or similar for ORM if chosen)\nFlask-Migrate (optional, for schema changes)\npython-dotenv (optional, for environment variables)\n",
        ".gitignore": "# Python\n__pycache__/\n*.pyc\n*.pyo\n*.pyd\n.Python\n\n# Virtual environment\nvirtualenv/\nvirtual_env/\nv_env/\nenv/\nvenv/\n\n# Database\ninstance/*.db\n*.sqlite3\n\n# Environment variables\n.env\n\n# IDE\n.idea/\n.vscode/",
        "config.py": "import os\n\n# Determine the base directory of the application\nBASE_DIR = os.path.abspath(os.path.dirname(__file__))\n\n# Database configuration\n# SQLite database file path. It will be created in the project root directory.\nDATABASE_PATH = os.path.join(BASE_DIR, 'products.db')\n\n# Flask application configuration\n# A secret key is required for Flask sessions and other security features.\n# In a production environment, this should be loaded from an environment variable\n# or a secure configuration management system.\nSECRET_KEY = os.environ.get('SECRET_KEY') or 'a_very_secret_and_random_key_for_dev'\n\n# You can add more configuration variables here if needed, e.g.,\n# DEBUG = True # Set to False in production\n# TESTING = False",
        "run.py": "import sqlite3\nimport uuid\nfrom flask import Flask, request, jsonify, g\n\n# Configuration\nDATABASE = 'products.db'\nDEBUG = True\n\napp = Flask(__name__)\napp.config.from_object(__name__)\n\ndef get_db():\n    \"\"\"Establishes a database connection or returns the existing one.\"\"\"\n    if 'db' not in g:\n        g.db = sqlite3.connect(\n            app.config['DATABASE'],\n            detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row  # This allows accessing columns by name\n    return g.db\n\ndef close_db(e=None):\n    \"\"\"Closes the database connection at the end of the request.\"\"\"\n    db = g.pop('db', None)\n    if db is not None:\n        db.close()\n\ndef init_db():\n    \"\"\"Initializes the database schema.\"\"\"\n    with app.app_context():\n        db = get_db()\n        cursor = db.cursor()\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id TEXT PRIMARY KEY,\n                name TEXT NOT NULL,\n                description TEXT,\n                price REAL NOT NULL,\n                stock_quantity INTEGER NOT NULL\n            );\n        \"\"\")\n        db.commit()\n\n# Register the close_db function to be called after each request\napp.teardown_appcontext(close_db)\n\n# Initialize the database when the application starts\nwith app.app_context():\n    init_db()\n\n# Helper function to convert a Row object to a dictionary\ndef product_to_dict(product_row):\n    if product_row is None:\n        return None\n    return {\n        \"id\": product_row[\"id\"],\n        \"name\": product_row[\"name\"],\n        \"description\": product_row[\"description\"],\n        \"price\": float(product_row[\"price\"]),  # Ensure price is float\n        \"stock_quantity\": int(product_row[\"stock_quantity\"]) # Ensure stock_quantity is int\n    }\n\n# Error Handlers\n@app.errorhandler(400)\ndef bad_request(error):\n    return jsonify({\"error\": \"Bad Request\", \"message\": str(error)}), 400\n\n@app.errorhandler(404)\ndef not_found(error):\n    return jsonify({\"error\": \"Not Found\", \"message\": str(error)}), 404\n\n@app.errorhandler(405)\ndef method_not_allowed(error):\n    return jsonify({\"error\": \"Method Not Allowed\", \"message\": str(error)}), 405\n\n@app.errorhandler(500)\ndef internal_server_error(error):\n    return jsonify({\"error\": \"Internal Server Error\", \"message\": str(error)}), 500\n\n# API Endpoints\n\n@app.route('/products', methods=['POST'])\ndef create_product():\n    \"\"\"\n    Creates a new product.\n    Requires: name (string), price (float), stock_quantity (integer).\n    Optional: description (string).\n    \"\"\"\n    data = request.get_json()\n    if not data:\n        return bad_request(\"Request body must be JSON.\")\n\n    name = data.get('name')\n    price = data.get('price')\n    stock_quantity = data.get('stock_quantity')\n    description = data.get('description')\n\n    if not all([name, price is not None, stock_quantity is not None]):\n        return bad_request(\"Missing required fields: 'name', 'price', and 'stock_quantity'.\")\n\n    try:\n        price = float(price)\n        stock_quantity = int(stock_quantity)\n        if price < 0 or stock_quantity < 0:\n            return bad_request(\"Price and stock_quantity must be non-negative.\")\n    except (ValueError, TypeError):\n        return bad_request(\"Invalid data types for 'price' (float) or 'stock_quantity' (integer).\")\n\n    product_id = str(uuid.uuid4())\n\n    db = get_db()\n    try:\n        cursor = db.cursor()\n        cursor.execute(\n            \"INSERT INTO products (id, name, description, price, stock_quantity) VALUES (?, ?, ?, ?, ?)\",\n            (product_id, name, description, price, stock_quantity)\n        )\n        db.commit()\n\n        # Retrieve the newly created product to return it\n        cursor.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,))\n        new_product = cursor.fetchone()\n        return jsonify(product_to_dict(new_product)), 201\n    except sqlite3.Error as e:\n        db.rollback()\n        return internal_server_error(f\"Database error: {e}\")\n\n@app.route('/products', methods=['GET'])\ndef get_all_products():\n    \"\"\"Retrieves a list of all products.\"\"\"\n    db = get_db()\n    cursor = db.cursor()\n    cursor.execute(\"SELECT * FROM products\")\n    products = cursor.fetchall()\n    return jsonify([product_to_dict(p) for p in products]), 200\n\n@app.route('/products/<string:product_id>', methods=['GET'])\ndef get_product_by_id(product_id):\n    \"\"\"Retrieves details for a specific product by its unique ID.\"\"\"\n    db = get_db()\n    cursor = db.cursor()\n    cursor.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,))\n    product = cursor.fetchone()\n\n    if product is None:\n        return not_found(f\"Product with ID '{product_id}' not found.\")\n    \n    return jsonify(product_to_dict(product)), 200\n\n@app.route('/products/<string:product_id>', methods=['PUT'])\ndef update_product(product_id):\n    \"\"\"\n    Modifies an existing product's details by ID, supporting partial updates.\n    Fields that can be updated: name (string), description (string), price (float), stock_quantity (integer).\n    \"\"\"\n    data = request.get_json()\n    if not data:\n        return bad_request(\"Request body must be JSON.\")\n\n    db = get_db()\n    cursor = db.cursor()\n\n    # Check if product exists\n    cursor.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,))\n    existing_product = cursor.fetchone()\n    if existing_product is None:\n        return not_found(f\"Product with ID '{product_id}' not found.\")\n\n    update_fields = []\n    update_values = []\n\n    # Dynamically build the update query for partial updates\n    if 'name' in data:\n        if not isinstance(data['name'], str) or not data['name'].strip():\n            return bad_request(\"Name must be a non-empty string.\")\n        update_fields.append(\"name = ?\")\n        update_values.append(data['name'])\n    if 'description' in data:\n        if not isinstance(data['description'], (str, type(None))):\n            return bad_request(\"Description must be a string or null.\")\n        update_fields.append(\"description = ?\")\n        update_values.append(data['description'])\n    if 'price' in data:\n        try:\n            price = float(data['price'])\n            if price < 0:\n                return bad_request(\"Price must be non-negative.\")\n            update_fields.append(\"price = ?\")\n            update_values.append(price)\n        except (ValueError, TypeError):\n            return bad_request(\"Invalid data type for 'price' (float).\")\n    if 'stock_quantity' in data:\n        try:\n            stock_quantity = int(data['stock_quantity'])\n            if stock_quantity < 0:\n                return bad_request(\"Stock quantity must be non-negative.\")\n            update_fields.append(\"stock_quantity = ?\")\n            update_values.append(stock_quantity)\n        except (ValueError, TypeError):\n            return bad_request(\"Invalid data type for 'stock_quantity' (integer).\")\n\n    if not update_fields:\n        return bad_request(\"No valid fields provided for update.\")\n\n    update_query = \"UPDATE products SET \" + \", \".join(update_fields) + \" WHERE id = ?\"\n    update_values.append(product_id)\n\n    try:\n        cursor.execute(update_query, tuple(update_values))\n        db.commit()\n\n        # Retrieve the updated product to return it\n        cursor.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,))\n        updated_product = cursor.fetchone()\n        return jsonify(product_to_dict(updated_product)), 200\n    except sqlite3.Error as e:\n        db.rollback()\n        return internal_server_error(f\"Database error: {e}\")\n\n@app.route('/products/<string:product_id>', methods=['DELETE'])\ndef delete_product(product_id):\n    \"\"\"Removes a product from the system using its ID.\"\"\"\n    db = get_db()\n    cursor = db.cursor()\n    try:\n        cursor.execute(\"DELETE FROM products WHERE id = ?\", (product_id,))\n        db.commit()\n\n        if cursor.rowcount == 0:\n            return not_found(f\"Product with ID '{product_id}' not found.\")\n        \n        return jsonify({\"message\": \"Product deleted successfully.\"}), 200\n    except sqlite3.Error as e:\n        db.rollback()\n        return internal_server_error(f\"Database error: {e}\")\n\nif __name__ == '__main__':\n    app.run(debug=app.config['DEBUG'])",
        "app/__init__.py": "import sqlite3\nimport uuid\nfrom flask import Flask, request, jsonify, g\nfrom werkzeug.exceptions import HTTPException\n\n# Database configuration\nDATABASE = 'database.db'\n\ndef get_db():\n    \"\"\"\n    Establishes a database connection or returns the existing one.\n    The connection is stored in Flask's `g` object, which is unique per request.\n    \"\"\"\n    if 'db' not in g:\n        g.db = sqlite3.connect(\n            DATABASE,\n            detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        # Configure row_factory to return rows that behave like dictionaries\n        g.db.row_factory = sqlite3.Row\n    return g.db\n\ndef close_db(e=None):\n    \"\"\"\n    Closes the database connection at the end of the request.\n    \"\"\"\n    db = g.pop('db', None)\n    if db is not None:\n        db.close()\n\ndef init_db():\n    \"\"\"\n    Initializes the database schema.\n    This function should be called once, typically via a Flask CLI command.\n    \"\"\"\n    db = get_db()\n    # Database schema from project context\n    schema = \"\"\"\n    CREATE TABLE IF NOT EXISTS products (\n        id TEXT PRIMARY KEY,\n        name TEXT NOT NULL,\n        description TEXT,\n        price REAL NOT NULL,\n        stock_quantity INTEGER NOT NULL\n    );\n    \"\"\"\n    db.executescript(schema)\n    db.commit()\n\ndef create_app():\n    \"\"\"\n    Factory function to create and configure the Flask application.\n    \"\"\"\n    app = Flask(__name__)\n\n    # Register the close_db function to be called after each request\n    app.teardown_appcontext(close_db)\n\n    # Add a command to initialize the database via Flask CLI\n    # To run: flask --app app init-db\n    @app.cli.command('init-db')\n    def init_db_command():\n        \"\"\"Clear the existing data and create new tables.\"\"\"\n        init_db()\n        print('Initialized the database.')\n\n    # Custom error handlers for JSON responses\n    @app.errorhandler(400)\n    def bad_request(error):\n        # For HTTPException, description is usually set. For others, use a default.\n        message = getattr(error, 'description', 'The request could not be understood by the server due to malformed syntax.')\n        return jsonify({\"error\": \"Bad Request\", \"message\": message}), 400\n\n    @app.errorhandler(404)\n    def not_found(error):\n        message = getattr(error, 'description', 'The requested resource was not found on the server.')\n        return jsonify({\"error\": \"Not Found\", \"message\": message}), 404\n\n    # API Endpoints\n\n    @app.route('/products', methods=['POST'])\n    def create_product():\n        \"\"\"\n        Creates a new product.\n        Expects JSON with 'name', 'price', 'stock_quantity', and optional 'description'.\n        \"\"\"\n        data = request.get_json()\n        if not data:\n            return jsonify({\"error\": \"Invalid JSON\", \"message\": \"Request body must be JSON.\"}), 400\n\n        name = data.get('name')\n        price = data.get('price')\n        stock_quantity = data.get('stock_quantity')\n        description = data.get('description', '') # Default to empty string if not provided\n\n        # Input validation\n        if not isinstance(name, str) or not name.strip():\n            return jsonify({\"error\": \"Validation Error\", \"message\": \"Product 'name' is required and must be a non-empty string.\"}), 400\n        if not isinstance(price, (int, float)) or price < 0:\n            return jsonify({\"error\": \"Validation Error\", \"message\": \"Product 'price' is required and must be a non-negative number.\"}), 400\n        if not isinstance(stock_quantity, int) or stock_quantity < 0:\n            return jsonify({\"error\": \"Validation Error\", \"message\": \"Product 'stock_quantity' is required and must be a non-negative integer.\"}), 400\n        if description is not None and not isinstance(description, str):\n            return jsonify({\"error\": \"Validation Error\", \"message\": \"Product 'description' must be a string or null.\"}), 400\n\n        product_id = str(uuid.uuid4())\n        db = get_db()\n        try:\n            db.execute(\n                \"INSERT INTO products (id, name, description, price, stock_quantity) VALUES (?, ?, ?, ?, ?)\",\n                (product_id, name.strip(), description.strip(), price, stock_quantity)\n            )\n            db.commit()\n        except sqlite3.Error as e:\n            # Catch specific SQLite errors for better debugging/logging\n            return jsonify({\"error\": \"Database Error\", \"message\": f\"Failed to create product: {e}\"}), 500\n        except Exception as e:\n            # Catch any other unexpected errors\n            return jsonify({\"error\": \"Internal Server Error\", \"message\": f\"An unexpected error occurred: {e}\"}), 500\n\n        new_product = {\n            \"id\": product_id,\n            \"name\": name.strip(),\n            \"description\": description.strip(),\n            \"price\": price,\n            \"stock_quantity\": stock_quantity\n        }\n        return jsonify(new_product), 201\n\n    @app.route('/products', methods=['GET'])\n    def get_all_products():\n        \"\"\"\n        Retrieves a list of all products.\n        \"\"\"\n        db = get_db()\n        products = db.execute(\"SELECT * FROM products\").fetchall()\n        # Convert Row objects to dictionaries for jsonify\n        return jsonify([dict(product) for product in products]), 200\n\n    @app.route('/products/<string:product_id>', methods=['GET'])\n    def get_product(product_id):\n        \"\"\"\n        Retrieves details for a specific product by its unique ID.\n        \"\"\"\n        db = get_db()\n        product = db.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,)).fetchone()\n        if product is None:\n            return jsonify({\"error\": \"Not Found\", \"message\": f\"Product with ID '{product_id}' not found.\"}), 404\n        return jsonify(dict(product)), 200\n\n    @app.route('/products/<string:product_id>', methods=['PUT'])\n    def update_product(product_id):\n        \"\"\"\n        Modifies an existing product's details by ID, supporting partial updates.\n        Expects JSON with fields to update.\n        \"\"\"\n        data = request.get_json()\n        if not data:\n            return jsonify({\"error\": \"Invalid JSON\", \"message\": \"Request body must be JSON.\"}), 400\n\n        db = get_db()\n        product = db.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,)).fetchone()\n        if product is None:\n            return jsonify({\"error\": \"Not Found\", \"message\": f\"Product with ID '{product_id}' not found.\"}), 404\n\n        updates = {}\n        # Validate and collect updates\n        if 'name' in data:\n            if not isinstance(data['name'], str) or not data['name'].strip():\n                return jsonify({\"error\": \"Validation Error\", \"message\": \"Product 'name' must be a non-empty string.\"}), 400\n            updates['name'] = data['name'].strip()\n        if 'description' in data:\n            # Allow description to be null or empty string\n            if data['description'] is not None and not isinstance(data['description'], str):\n                return jsonify({\"error\": \"Validation Error\", \"message\": \"Product 'description' must be a string or null.\"}), 400\n            updates['description'] = data['description'].strip() if data['description'] else ''\n        if 'price' in data:\n            if not isinstance(data['price'], (int, float)) or data['price'] < 0:\n                return jsonify({\"error\": \"Validation Error\", \"message\": \"Product 'price' must be a non-negative number.\"}), 400\n            updates['price'] = data['price']\n        if 'stock_quantity' in data:\n            if not isinstance(data['stock_quantity'], int) or data['stock_quantity'] < 0:\n                return jsonify({\"error\": \"Validation Error\", \"message\": \"Product 'stock_quantity' must be a non-negative integer.\"}), 400\n            updates['stock_quantity'] = data['stock_quantity']\n\n        if not updates:\n            return jsonify({\"error\": \"No Content\", \"message\": \"No valid fields provided for update.\"}), 400\n\n        # Construct the UPDATE query dynamically\n        set_clauses = []\n        values = []\n        for key, value in updates.items():\n            set_clauses.append(f\"{key} = ?\")\n            values.append(value)\n\n        values.append(product_id) # Add product_id for the WHERE clause\n\n        try:\n            db.execute(\n                f\"UPDATE products SET {', '.join(set_clauses)} WHERE id = ?\",\n                tuple(values)\n            )\n            db.commit()\n        except sqlite3.Error as e:\n            return jsonify({\"error\": \"Database Error\", \"message\": f\"Failed to update product: {e}\"}), 500\n        except Exception as e:\n            return jsonify({\"error\": \"Internal Server Error\", \"message\": f\"An unexpected error occurred during update: {e}\"}), 500\n\n        # Retrieve and return the updated product details\n        updated_product = db.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,)).fetchone()\n        return jsonify(dict(updated_product)), 200\n\n    @app.route('/products/<string:product_id>', methods=['DELETE'])\n    def delete_product(product_id):\n        \"\"\"\n        Removes a product from the system using its ID.\n        \"\"\"\n        db = get_db()\n        cursor = db.execute(\"DELETE FROM products WHERE id = ?\", (product_id,))\n        db.commit()\n\n        if cursor.rowcount == 0:\n            return jsonify({\"error\": \"Not Found\", \"message\": f\"Product with ID '{product_id}' not found.\"}), 404\n        \n        return jsonify({\"message\": \"Product deleted successfully.\"}), 200\n\n    return app",
        "app/models.py": "import uuid\nfrom flask_sqlalchemy import SQLAlchemy\n\n# Initialize SQLAlchemy. This 'db' object will be initialized with the Flask app later\n# in the application's main file (e.g., app.py or __init__.py).\ndb = SQLAlchemy()\n\nclass Product(db.Model):\n    \"\"\"\n    Represents a product in the inventory system.\n    Maps to the 'products' table in the database.\n    \"\"\"\n    __tablename__ = 'products'\n\n    id = db.Column(db.Text, primary_key=True, default=lambda: str(uuid.uuid4()))\n    name = db.Column(db.Text, nullable=False)\n    description = db.Column(db.Text, nullable=True) # Optional as per FR1\n    price = db.Column(db.Float, nullable=False)\n    stock_quantity = db.Column(db.Integer, nullable=False)\n\n    def __init__(self, name, price, stock_quantity, description=None):\n        \"\"\"\n        Initializes a new Product instance.\n        ID is automatically generated by the default value of the column.\n        \"\"\"\n        self.name = name\n        self.description = description\n        self.price = price\n        self.stock_quantity = stock_quantity\n\n    def __repr__(self):\n        \"\"\"\n        Provides a string representation of the Product object for debugging.\n        \"\"\"\n        return f'<Product {self.id}: {self.name}>'\n\n    def to_dict(self):\n        \"\"\"\n        Converts the Product object to a dictionary, suitable for JSON serialization\n        in API responses.\n        \"\"\"\n        return {\n            'id': self.id,\n            'name': self.name,\n            'description': self.description,\n            'price': self.price,\n            'stock_quantity': self.stock_quantity\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"\n        Creates a new Product instance from a dictionary (e.g., from a request body).\n        This method is useful for creating new products.\n        \"\"\"\n        return cls(\n            name=data.get('name'),\n            description=data.get('description'),\n            price=data.get('price'),\n            stock_quantity=data.get('stock_quantity')\n        )\n\n    def update_from_dict(self, data):\n        \"\"\"\n        Updates the current Product instance with data from a dictionary,\n        supporting partial updates. Only provided fields will be updated.\n        \"\"\"\n        if 'name' in data:\n            self.name = data['name']\n        if 'description' in data:\n            self.description = data['description']\n        if 'price' in data:\n            self.price = data['price']\n        if 'stock_quantity' in data:\n            self.stock_quantity = data['stock_quantity']",
        "app/routes.py": "import sqlite3\nimport uuid\nfrom flask import request, jsonify, abort, g, current_app\n\n# Database configuration\nDATABASE = 'database.db'\n\ndef get_db():\n    \"\"\"Establishes a database connection or returns the existing one.\"\"\"\n    db = getattr(g, '_database', None)\n    if db is None:\n        db = g._database = sqlite3.connect(DATABASE)\n        db.row_factory = sqlite3.Row  # This makes rows behave like dictionaries\n    return db\n\ndef close_connection(exception):\n    \"\"\"Closes the database connection at the end of the request.\"\"\"\n    db = getattr(g, '_database', None)\n    if db is not None:\n        db.close()\n\ndef init_db():\n    \"\"\"Initializes the database schema from schema.sql.\"\"\"\n    with current_app.app_context():\n        db = get_db()\n        # The schema.sql file is expected to be in the same directory as app.py or accessible via app.open_resource\n        with current_app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\ndef register_routes(app):\n    \"\"\"Registers all API routes with the Flask application instance.\"\"\"\n    app.teardown_appcontext(close_connection)\n\n    @app.route('/products', methods=['POST'])\n    def create_product():\n        data = request.get_json()\n        if not data:\n            abort(400, description=\"Request body must be JSON.\")\n\n        name = data.get('name')\n        price = data.get('price')\n        stock_quantity = data.get('stock_quantity')\n        description = data.get('description') # Optional\n\n        # Validate required fields\n        if not all([name, price is not None, stock_quantity is not None]):\n            abort(400, description=\"Missing required fields: 'name', 'price', 'stock_quantity'.\")\n\n        # Validate data types and constraints\n        if not isinstance(name, str) or not name.strip():\n            abort(400, description=\"Name must be a non-empty string.\")\n        \n        try:\n            price = float(price)\n            if price < 0:\n                abort(400, description=\"Price cannot be negative.\")\n        except (ValueError, TypeError):\n            abort(400, description=\"Price must be a valid number.\")\n        \n        try:\n            stock_quantity = int(stock_quantity)\n            if stock_quantity < 0:\n                abort(400, description=\"Stock quantity cannot be negative.\")\n        except (ValueError, TypeError):\n            abort(400, description=\"Stock quantity must be a valid integer.\")\n        \n        if description is not None and not isinstance(description, str):\n            abort(400, description=\"Description must be a string or null.\")\n\n        product_id = str(uuid.uuid4())\n\n        db = get_db()\n        try:\n            db.execute(\n                \"INSERT INTO products (id, name, description, price, stock_quantity) VALUES (?, ?, ?, ?, ?)\",\n                (product_id, name, description, price, stock_quantity)\n            )\n            db.commit()\n        except sqlite3.Error:\n            abort(500, description=\"Failed to create product due to a database error.\")\n\n        new_product = {\n            \"id\": product_id,\n            \"name\": name,\n            \"description\": description,\n            \"price\": price,\n            \"stock_quantity\": stock_quantity\n        }\n        return jsonify(new_product), 201\n\n    @app.route('/products', methods=['GET'])\n    def get_all_products():\n        db = get_db()\n        cursor = db.execute(\"SELECT id, name, description, price, stock_quantity FROM products\")\n        products = [dict(row) for row in cursor.fetchall()]\n        return jsonify(products)\n\n    @app.route('/products/<string:product_id>', methods=['GET'])\n    def get_product(product_id):\n        db = get_db()\n        cursor = db.execute(\n            \"SELECT id, name, description, price, stock_quantity FROM products WHERE id = ?\",\n            (product_id,)\n        )\n        product = cursor.fetchone()\n        if product is None:\n            abort(404, description=\"Product not found.\")\n        return jsonify(dict(product))\n\n    @app.route('/products/<string:product_id>', methods=['PUT'])\n    def update_product(product_id):\n        data = request.get_json()\n        if not data:\n            abort(400, description=\"Request body must be JSON.\")\n\n        db = get_db()\n        cursor = db.execute(\"SELECT id FROM products WHERE id = ?\", (product_id,))\n        existing_product = cursor.fetchone()\n\n        if existing_product is None:\n            abort(404, description=\"Product not found.\")\n\n        updates = {}\n        # Process potential updates and validate\n        if 'name' in data:\n            if not isinstance(data['name'], str) or not data['name'].strip():\n                abort(400, description=\"Name must be a non-empty string.\")\n            updates['name'] = data['name']\n        \n        if 'description' in data:\n            if data['description'] is not None and not isinstance(data['description'], str):\n                abort(400, description=\"Description must be a string or null.\")\n            updates['description'] = data['description']\n        \n        if 'price' in data:\n            try:\n                price = float(data['price'])\n                if price < 0:\n                    abort(400, description=\"Price cannot be negative.\")\n                updates['price'] = price\n            except (ValueError, TypeError):\n                abort(400, description=\"Price must be a valid number.\")\n        \n        if 'stock_quantity' in data:\n            try:\n                stock_quantity = int(data['stock_quantity'])\n                if stock_quantity < 0:\n                    abort(400, description=\"Stock quantity cannot be negative.\")\n                updates['stock_quantity'] = stock_quantity\n            except (ValueError, TypeError):\n                abort(400, description=\"Stock quantity must be a valid integer.\")\n\n        if not updates:\n            abort(400, description=\"No valid fields provided for update.\")\n\n        set_clauses = []\n        values = []\n        for key, value in updates.items():\n            set_clauses.append(f\"{key} = ?\")\n            values.append(value)\n\n        values.append(product_id) # Add product_id for WHERE clause\n\n        try:\n            db.execute(\n                f\"UPDATE products SET {', '.join(set_clauses)} WHERE id = ?\",\n                tuple(values)\n            )\n            db.commit()\n        except sqlite3.Error:\n            abort(500, description=\"An unexpected error occurred during update.\")\n\n        # Retrieve the updated product to return\n        cursor = db.execute(\n            \"SELECT id, name, description, price, stock_quantity FROM products WHERE id = ?\",\n            (product_id,)\n        )\n        updated_product = cursor.fetchone()\n        return jsonify(dict(updated_product))\n\n    @app.route('/products/<string:product_id>', methods=['DELETE'])\n    def delete_product(product_id):\n        db = get_db()\n        cursor = db.execute(\"SELECT id FROM products WHERE id = ?\", (product_id,))\n        product = cursor.fetchone()\n\n        if product is None:\n            abort(404, description=\"Product not found.\")\n\n        try:\n            db.execute(\"DELETE FROM products WHERE id = ?\", (product_id,))\n            db.commit()\n        except sqlite3.Error:\n            abort(500, description=\"An unexpected error occurred during deletion.\")\n\n        return jsonify({\"message\": \"Product deleted successfully.\"}), 200",
        "app/database.py": "import sqlite3\nimport uuid\nimport os\n\n# Define the path for the SQLite database file.\n# This assumes the 'instance' directory is a sibling to the 'app' directory,\n# which is a common Flask convention for instance-specific files.\nBASE_DIR = os.path.dirname(os.path.abspath(__file__)) # This is 'app/'\nPROJECT_ROOT = os.path.dirname(BASE_DIR) # This is the project root directory\nINSTANCE_DIR = os.path.join(PROJECT_ROOT, 'instance')\nDATABASE_PATH = os.path.join(INSTANCE_DIR, 'database.db')\n\ndef get_db_connection():\n    \"\"\"\n    Establishes a connection to the SQLite database.\n    Sets row_factory to sqlite3.Row to allow accessing columns by name.\n    \"\"\"\n    conn = sqlite3.connect(DATABASE_PATH)\n    conn.row_factory = sqlite3.Row\n    return conn\n\ndef init_db():\n    \"\"\"\n    Initializes the database by creating the 'products' table if it doesn't already exist.\n    Ensures the 'instance' directory exists.\n    \"\"\"\n    # Ensure the instance directory exists before trying to create the database file\n    os.makedirs(INSTANCE_DIR, exist_ok=True)\n    \n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS products (\n            id TEXT PRIMARY KEY,\n            name TEXT NOT NULL,\n            description TEXT,\n            price REAL NOT NULL,\n            stock_quantity INTEGER NOT NULL\n        );\n    ''')\n    conn.commit()\n    conn.close()\n\ndef create_product(name: str, description: str, price: float, stock_quantity: int) -> dict | None:\n    \"\"\"\n    Creates a new product entry in the database.\n    A unique ID (UUID) is automatically generated for the product.\n    Returns the created product's details as a dictionary, or None if creation fails.\n    \"\"\"\n    product_id = str(uuid.uuid4())\n    conn = get_db_connection()\n    try:\n        conn.execute(\n            'INSERT INTO products (id, name, description, price, stock_quantity) VALUES (?, ?, ?, ?, ?)',\n            (product_id, name, description, price, stock_quantity)\n        )\n        conn.commit()\n        # Return the newly created product's details\n        return get_product_by_id(product_id)\n    except sqlite3.Error:\n        conn.rollback()\n        return None\n    finally:\n        conn.close()\n\ndef get_all_products() -> list[dict]:\n    \"\"\"\n    Retrieves a list of all products from the database.\n    Returns a list of dictionaries, where each dictionary represents a product.\n    \"\"\"\n    conn = get_db_connection()\n    products = conn.execute('SELECT * FROM products').fetchall()\n    conn.close()\n    # Convert sqlite3.Row objects to standard dictionaries for easier use (e.g., JSON serialization)\n    return [dict(product) for product in products]\n\ndef get_product_by_id(product_id: str) -> dict | None:\n    \"\"\"\n    Retrieves details for a specific product by its unique ID.\n    Returns the product's details as a dictionary, or None if the product is not found.\n    \"\"\"\n    conn = get_db_connection()\n    product = conn.execute('SELECT * FROM products WHERE id = ?', (product_id,)).fetchone()\n    conn.close()\n    return dict(product) if product else None\n\ndef update_product(product_id: str, updates: dict) -> dict | None:\n    \"\"\"\n    Modifies an existing product's details by its ID.\n    Supports partial updates: only the fields present in the 'updates' dictionary will be modified.\n    Returns the updated product's details as a dictionary, or None if the product is not found or update fails.\n    \"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n\n    # First, check if the product exists\n    existing_product = get_product_by_id(product_id)\n    if not existing_product:\n        conn.close()\n        return None # Product not found\n\n    set_clauses = []\n    params = []\n    \n    # Define allowed fields to prevent arbitrary column updates\n    allowed_fields = ['name', 'description', 'price', 'stock_quantity']\n\n    for field in allowed_fields:\n        if field in updates:\n            set_clauses.append(f\"{field} = ?\")\n            params.append(updates[field])\n\n    if not set_clauses:\n        conn.close()\n        return existing_product # No valid fields provided for update, return existing product\n\n    params.append(product_id) # Add product_id for the WHERE clause\n\n    query = f\"UPDATE products SET {', '.join(set_clauses)} WHERE id = ?\"\n\n    try:\n        cursor.execute(query, tuple(params))\n        conn.commit()\n        # Return the updated product's details\n        return get_product_by_id(product_id)\n    except sqlite3.Error:\n        conn.rollback()\n        return None\n    finally:\n        conn.close()\n\ndef delete_product(product_id: str) -> bool:\n    \"\"\"\n    Removes a product from the system using its ID.\n    Returns True if the product was successfully deleted, False otherwise.\n    \"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    try:\n        cursor.execute('DELETE FROM products WHERE id = ?', (product_id,))\n        conn.commit()\n        return cursor.rowcount > 0 # True if a row was deleted, False otherwise\n    except sqlite3.Error:\n        conn.rollback()\n        return False\n    finally:\n        conn.close()",
        "app/errors.py": "class APIError(Exception):\n    \"\"\"Base class for custom API errors.\"\"\"\n    status_code = 500\n    message = \"An unexpected error occurred.\"\n\n    def __init__(self, message=None, status_code=None, payload=None):\n        super().__init__(self)\n        if message is not None:\n            self.message = message\n        if status_code is not None:\n            self.status_code = status_code\n        self.payload = payload\n\n    def to_dict(self):\n        \"\"\"Converts the error details to a dictionary for JSON response.\"\"\"\n        rv = dict(self.payload or ())\n        rv['message'] = self.message\n        return rv\n\nclass BadRequest(APIError):\n    \"\"\"Custom error for 400 Bad Request.\"\"\"\n    status_code = 400\n    message = \"Bad Request: The request could not be understood or was missing required parameters.\"\n\nclass NotFound(APIError):\n    \"\"\"Custom error for 404 Not Found.\"\"\"\n    status_code = 404\n    message = \"Not Found: The requested resource could not be found.\"\n\nclass Conflict(APIError):\n    \"\"\"Custom error for 409 Conflict.\"\"\"\n    status_code = 409\n    message = \"Conflict: The request could not be completed due to a conflict with the current state of the resource.\"",
        "app/utils.py": "import sqlite3\nimport uuid\nfrom flask import g, current_app\n\ndef get_db():\n    \"\"\"\n    Establishes a database connection if one is not already present in the current request context.\n    The database path is retrieved from the Flask application's configuration.\n    Rows are returned as sqlite3.Row objects, allowing dictionary-like access.\n    \"\"\"\n    if 'db' not in g:\n        g.db = sqlite3.connect(\n            current_app.config['DATABASE'],\n            detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n    return g.db\n\ndef close_db(e=None):\n    \"\"\"\n    Closes the database connection at the end of a request.\n    This function is typically registered with app.teardown_appcontext.\n    \"\"\"\n    db = g.pop('db', None)\n    if db is not None:\n        db.close()\n\ndef init_db():\n    \"\"\"\n    Initializes the database schema by executing the SQL script from 'schema.sql'.\n    This function should be called once, e.g., during application setup or via a CLI command.\n    \"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql') as f:\n        db.executescript(f.read().decode('utf8'))\n\ndef generate_uuid():\n    \"\"\"\n    Generates a unique UUID (Universally Unique Identifier) string.\n    This is used for product IDs as specified in the system design.\n    \"\"\"\n    return str(uuid.uuid4())",
        "instance/app.db": "CREATE TABLE products (\n    id TEXT PRIMARY KEY,\n    name TEXT NOT NULL,\n    description TEXT,\n    price REAL NOT NULL,\n    stock_quantity INTEGER NOT NULL\n);"
    }
}