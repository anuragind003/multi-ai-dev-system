package com.ltfs.cdp.adminportal.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Service class responsible for managing and providing access to error and success files
 * generated by batch processing or data ingestion within the LTFS Offer CDP system.
 * It handles file listing, retrieval, and ensures secure access to designated file storage locations.
 */
@Service
public class ErrorSuccessFileManager {

    private static final Logger logger = LoggerFactory.getLogger(ErrorSuccessFileManager.class);

    // Base path for file storage, configured via application properties (e.g., cdp.file.storage.base-path=/opt/cdp/data/files)
    @Value("${cdp.file.storage.base-path}")
    private String fileStorageBasePath;

    // Subdirectory for error files, configurable with a default value (e.g., cdp.file.storage.error-subdir=errors)
    @Value("${cdp.file.storage.error-subdir:errors}")
    private String errorSubdir;

    // Subdirectory for success files, configurable with a default value (e.g., cdp.file.storage.success-subdir=success)
    @Value("${cdp.file.storage.success-subdir:success}")
    private String successSubdir;

    /**
     * Constructs the absolute and normalized path for the base file storage directory.
     *
     * @return Path object representing the base file storage directory.
     */
    private Path getBaseStoragePath() {
        return Paths.get(fileStorageBasePath).toAbsolutePath().normalize();
    }

    /**
     * Constructs the absolute and normalized path for the error files directory.
     * Ensures the directory exists, creating it if necessary.
     *
     * @return Path object representing the error files directory.
     * @throws IOException if the directory cannot be created due to I/O errors.
     */
    private Path getErrorDirectoryPath() throws IOException {
        Path errorDirPath = getBaseStoragePath().resolve(errorSubdir).normalize();
        if (!Files.exists(errorDirPath)) {
            try {
                Files.createDirectories(errorDirPath);
                logger.info("Created error file directory: {}", errorDirPath);
            } catch (IOException e) {
                logger.error("Failed to create error file directory: {}. Error: {}", errorDirPath, e.getMessage(), e);
                throw e; // Re-throw to indicate a critical setup failure
            }
        }
        return errorDirPath;
    }

    /**
     * Constructs the absolute and normalized path for the success files directory.
     * Ensures the directory exists, creating it if necessary.
     *
     * @return Path object representing the success files directory.
     * @throws IOException if the directory cannot be created due to I/O errors.
     */
    private Path getSuccessDirectoryPath() throws IOException {
        Path successDirPath = getBaseStoragePath().resolve(successSubdir).normalize();
        if (!Files.exists(successDirPath)) {
            try {
                Files.createDirectories(successDirPath);
                logger.info("Created success file directory: {}", successDirPath);
            } catch (IOException e) {
                logger.error("Failed to create success file directory: {}. Error: {}", successDirPath, e.getMessage(), e);
                throw e; // Re-throw to indicate a critical setup failure
            }
        }
        return successDirPath;
    }

    /**
     * Lists all file names (not directories) within a specified directory.
     *
     * @param directoryPath The Path object of the directory to list files from.
     * @return A list of file names (Strings) found in the directory. Returns an empty list if the directory
     *         does not exist, is not a directory, or an I/O error occurs.
     */
    private List<String> listFileNamesInDirectory(Path directoryPath) {
        if (!Files.exists(directoryPath) || !Files.isDirectory(directoryPath)) {
            logger.warn("Directory does not exist or is not a directory: {}", directoryPath);
            return List.of(); // Return empty list if directory doesn't exist or is invalid
        }
        try (Stream<Path> paths = Files.list(directoryPath)) {
            return paths
                    .filter(Files::isRegularFile) // Only include regular files
                    .map(Path::getFileName)       // Get just the file name
                    .map(Path::toString)          // Convert to String
                    .collect(Collectors.toList());
        } catch (IOException e) {
            logger.error("Failed to list files in directory {}: {}", directoryPath, e.getMessage(), e);
            return List.of(); // Return empty list on I/O error
        }
    }

    /**
     * Lists all available error file names.
     *
     * @return A list of strings, each representing an error file name. Returns an empty list on error.
     */
    public List<String> listErrorFileNames() {
        try {
            return listFileNamesInDirectory(getErrorDirectoryPath());
        } catch (IOException e) {
            logger.error("Failed to get error directory path: {}", e.getMessage(), e);
            return List.of(); // Return empty list if directory path cannot be resolved/created
        }
    }

    /**
     * Lists all available success file names.
     *
     * @return A list of strings, each representing a success file name. Returns an empty list on error.
     */
    public List<String> listSuccessFileNames() {
        try {
            return listFileNamesInDirectory(getSuccessDirectoryPath());
        } catch (IOException e) {
            logger.error("Failed to get success directory path: {}", e.getMessage(), e);
            return List.of(); // Return empty list if directory path cannot be resolved/created
        }
    }

    /**
     * Retrieves a file as a Spring Resource object, suitable for serving via an API endpoint.
     * This method performs crucial security checks to prevent path traversal vulnerabilities.
     *
     * @param fileType The type of file to retrieve ("error" or "success"). Case-insensitive.
     * @param fileName The name of the file to retrieve (e.g., "batch_20231026_errors.csv").
     * @return A Spring {@link Resource} object representing the file.
     * @throws IllegalArgumentException if an invalid file type is provided.
     * @throws SecurityException if an attempt at path traversal is detected.
     * @throws java.io.FileNotFoundException if the specified file does not exist or is not a regular file.
     * @throws IOException if an I/O error occurs during file access or URL creation.
     */
    public Resource getFileAsResource(String fileType, String fileName) throws IOException {
        Path targetDirectory;
        if ("error".equalsIgnoreCase(fileType)) {
            targetDirectory = getErrorDirectoryPath();
        } else if ("success".equalsIgnoreCase(fileType)) {
            targetDirectory = getSuccessDirectoryPath();
        } else {
            logger.warn("Invalid file type requested: {}", fileType);
            throw new IllegalArgumentException("Invalid file type. Must be 'error' or 'success'.");
        }

        // Resolve the requested file path within the target directory and normalize it.
        // Normalization resolves ".." and "." components.
        Path filePath = targetDirectory.resolve(fileName).normalize();

        // Security check: Ensure the resolved path is still contained within the intended target directory.
        // This is critical to prevent path traversal attacks (e.g., requesting "../../etc/passwd").
        if (!filePath.startsWith(targetDirectory)) {
            logger.warn("Attempted path traversal detected for file: {} in directory: {}", fileName, targetDirectory);
            throw new SecurityException("Access denied: Invalid file path. Path traversal attempt detected.");
        }

        // Verify that the file exists and is a regular file (not a directory or other special file).
        if (!Files.exists(filePath) || !Files.isRegularFile(filePath)) {
            logger.warn("File not found or is not a regular file: {}", filePath);
            throw new java.io.FileNotFoundException("File not found: " + fileName);
        }

        try {
            // Create a URL resource from the file path.
            UrlResource resource = new UrlResource(filePath.toUri());
            // Check if the resource exists and is readable.
            if (resource.exists() && resource.isReadable()) {
                return resource;
            } else {
                logger.warn("Could not read the file or file does not exist: {}", fileName);
                throw new IOException("Could not read the file: " + fileName);
            }
        } catch (MalformedURLException e) {
            logger.error("Malformed URL for file: {}. Error: {}", fileName, e.getMessage(), e);
            throw new IOException("Error creating URL for file: " + fileName, e);
        }
    }

    /**
     * Reads the entire content of a specified file into a byte array.
     * This method performs crucial security checks to prevent path traversal vulnerabilities.
     * Use this for relatively small files to avoid excessive memory consumption.
     *
     * @param fileType The type of file to read ("error" or "success"). Case-insensitive.
     * @param fileName The name of the file to read (e.g., "ingestion_20231025_summary.log").
     * @return A byte array containing the file's content.
     * @throws IllegalArgumentException if an invalid file type is provided.
     * @throws SecurityException if an attempt at path traversal is detected.
     * @throws java.io.FileNotFoundException if the specified file does not exist or is not a regular file.
     * @throws IOException if an I/O error occurs during file reading.
     */
    public byte[] getFileContentAsBytes(String fileType, String fileName) throws IOException {
        Path targetDirectory;
        if ("error".equalsIgnoreCase(fileType)) {
            targetDirectory = getErrorDirectoryPath();
        } else if ("success".equalsIgnoreCase(fileType)) {
            targetDirectory = getSuccessDirectoryPath();
        } else {
            logger.warn("Invalid file type requested: {}", fileType);
            throw new IllegalArgumentException("Invalid file type. Must be 'error' or 'success'.");
        }

        // Resolve the requested file path within the target directory and normalize it.
        Path filePath = targetDirectory.resolve(fileName).normalize();

        // Security check: Ensure the resolved path is still contained within the intended target directory.
        if (!filePath.startsWith(targetDirectory)) {
            logger.warn("Attempted path traversal detected for file: {} in directory: {}", fileName, targetDirectory);
            throw new SecurityException("Access denied: Invalid file path. Path traversal attempt detected.");
        }

        // Verify that the file exists and is a regular file.
        if (!Files.exists(filePath) || !Files.isRegularFile(filePath)) {
            logger.warn("File not found or is not a regular file: {}", filePath);
            throw new java.io.FileNotFoundException("File not found: " + fileName);
        }

        try {
            return Files.readAllBytes(filePath);
        } catch (IOException e) {
            logger.error("Failed to read content of file: {}. Error: {}", fileName, e.getMessage(), e);
            throw new IOException("Failed to read file content: " + fileName, e);
        }
    }
}