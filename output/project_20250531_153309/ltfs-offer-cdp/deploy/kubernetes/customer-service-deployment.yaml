apiVersion: apps/v1
kind: Deployment
metadata:
  name: customer-service-deployment
  labels:
    app: customer-service
    project: ltfs-offer-cdp # Project label for easy identification and management
spec:
  replicas: 2 # Scalability: Run 2 instances of the customer service for high availability and load balancing
  selector:
    matchLabels:
      app: customer-service # Selector to identify pods managed by this deployment
  template:
    metadata:
      labels:
        app: customer-service
        project: ltfs-offer-cdp
    spec:
      containers:
        - name: customer-service
          image: ltfs-offer-cdp/customer-service:latest # Docker image for the customer service. Replace 'latest' with a specific version tag in production.
          ports:
            - containerPort: 8080 # The port on which the Spring Boot application listens inside the container
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: kubernetes # Activates a Spring profile named 'kubernetes' for environment-specific configurations
            - name: SPRING_DATASOURCE_URL
              value: jdbc:postgresql://customer-db-service:5432/customer_db # Database connection URL. 'customer-db-service' is the assumed Kubernetes Service name for the PostgreSQL database.
            - name: SPRING_DATASOURCE_USERNAME
              valueFrom:
                secretKeyRef:
                  name: customer-db-credentials # Name of the Kubernetes Secret containing database credentials
                  key: username # Key within the secret for the database username
            - name: SPRING_DATASOURCE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: customer-db-credentials # Name of the Kubernetes Secret containing database credentials
                  key: password # Key within the secret for the database password
            # Add other environment variables as needed, e.g., for Kafka broker addresses, other service URLs
            # - name: KAFKA_BOOTSTRAP_SERVERS
            #   value: kafka-broker-service:9092
          resources: # Resource requests and limits to ensure performance and prevent resource exhaustion
            requests:
              memory: "512Mi" # Request 512 MiB of memory
              cpu: "500m" # Request 0.5 CPU core
            limits:
              memory: "1024Mi" # Limit to 1024 MiB (1 GiB) of memory
              cpu: "1000m" # Limit to 1 CPU core
          livenessProbe: # Liveness probe to check if the application is running and healthy. If it fails, Kubernetes restarts the container.
            httpGet:
              path: /actuator/health/liveness # Spring Boot Actuator endpoint for liveness checks
              port: 8080
            initialDelaySeconds: 30 # Wait 30 seconds before the first liveness check
            periodSeconds: 10 # Check every 10 seconds
            timeoutSeconds: 5 # Timeout after 5 seconds
            failureThreshold: 3 # After 3 consecutive failures, restart the container
          readinessProbe: # Readiness probe to check if the application is ready to serve traffic. If it fails, Kubernetes stops sending traffic to the pod.
            httpGet:
              path: /actuator/health/readiness # Spring Boot Actuator endpoint for readiness checks
              port: 8080
            initialDelaySeconds: 45 # Wait 45 seconds before the first readiness check
            periodSeconds: 15 # Check every 15 seconds
            timeoutSeconds: 5 # Timeout after 5 seconds
            failureThreshold: 3 # After 3 consecutive failures, mark the pod as unready
---
apiVersion: v1
kind: Service
metadata:
  name: customer-service # Name of the Kubernetes Service for the customer service
  labels:
    app: customer-service
    project: ltfs-offer-cdp
spec:
  selector:
    app: customer-service # Selects pods with the label 'app: customer-service' to route traffic to
  ports:
    - protocol: TCP
      port: 8080 # The port on which the service will be exposed within the cluster
      targetPort: 8080 # The port on the container to which the service will forward traffic
  type: ClusterIP # Service type: ClusterIP makes the service only reachable from within the cluster.
                  # Use LoadBalancer or NodePort if external access is required.