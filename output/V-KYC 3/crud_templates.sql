-- crud_templates.sql
-- Basic CRUD (Create, Read, Update, Delete) query templates for each table.
-- Use these as starting points for application development.

-- =============================================================================
-- USERS TABLE
-- =============================================================================

-- CREATE User
-- Note: password_hash should be generated by the application using a strong hashing algorithm (e.g., bcrypt).
-- Use the create_user stored procedure for robust creation and auditing.
-- CALL create_user('new_user', 'hashed_password_here', 'Team Lead', 'new_user@example.com', 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'::UUID, '192.168.1.100'::INET);
INSERT INTO users (username, password_hash, role, email)
VALUES ('{{username}}', '{{password_hash}}', '{{role}}', '{{email}}')
RETURNING id, created_at;

-- READ Users
-- Get all users
SELECT id, username, role, email, created_at FROM users;
-- Get user by ID
SELECT id, username, role, email, created_at FROM users WHERE id = '{{user_id}}';
-- Get user by username
SELECT id, username, role, email, created_at FROM users WHERE username = '{{username}}';
-- Get users by role
SELECT id, username, role, email, created_at FROM users WHERE role = '{{role}}';

-- UPDATE User
UPDATE users
SET
    username = '{{new_username}}',
    password_hash = '{{new_password_hash}}', -- Only update if password changes
    role = '{{new_role}}',
    email = '{{new_email}}'
WHERE id = '{{user_id}}'
RETURNING id, username, role, email;

-- DELETE User
DELETE FROM users WHERE id = '{{user_id}}' RETURNING id, username;
-- Note: Due to foreign key constraints (audit_logs, vkyc_recordings),
-- deleting a user with associated records will fail unless ON DELETE CASCADE is used
-- or associated records are deleted/reassigned first. ON DELETE RESTRICT is used here.

-- =============================================================================
-- VKYC_RECORDINGS TABLE
-- =============================================================================

-- CREATE V-KYC Recording
INSERT INTO vkyc_recordings (vkyc_case_id, customer_name, recording_date, duration_seconds, file_path, status, uploaded_by_user_id, metadata_json)
VALUES ('{{vkyc_case_id}}', '{{customer_name}}', '{{recording_date}}', {{duration_seconds}}, '{{file_path}}', '{{status}}', '{{uploaded_by_user_id}}', '{{metadata_json}}'::JSONB)
RETURNING id, created_at;

-- READ V-KYC Recordings
-- Get all recordings
SELECT id, vkyc_case_id, customer_name, recording_date, duration_seconds, file_path, status, uploaded_by_user_id, created_at, metadata_json FROM vkyc_recordings;
-- Get recording by ID
-- Use the get_vkyc_recording_details stored procedure for details with audit history.
-- SELECT * FROM get_vkyc_recording_details('{{vkyc_recording_id}}');
SELECT id, vkyc_case_id, customer_name, recording_date, duration_seconds, file_path, status, uploaded_by_user_id, created_at, metadata_json FROM vkyc_recordings WHERE id = '{{vkyc_recording_id}}';
-- Get recording by VKYC Case ID
SELECT id, vkyc_case_id, customer_name, recording_date, duration_seconds, file_path, status, uploaded_by_user_id, created_at, metadata_json FROM vkyc_recordings WHERE vkyc_case_id = '{{vkyc_case_id}}';
-- Get recordings by customer name (partial match)
SELECT id, vkyc_case_id, customer_name, recording_date, duration_seconds, file_path, status, uploaded_by_user_id, created_at, metadata_json FROM vkyc_recordings WHERE customer_name ILIKE '%{{customer_name_part}}%';
-- Get recordings by date range
SELECT id, vkyc_case_id, customer_name, recording_date, duration_seconds, file_path, status, uploaded_by_user_id, created_at, metadata_json FROM vkyc_recordings WHERE recording_date BETWEEN '{{start_date}}' AND '{{end_date}}';
-- Get recordings by status
SELECT id, vkyc_case_id, customer_name, recording_date, duration_seconds, file_path, status, uploaded_by_user_id, created_at, metadata_json FROM vkyc_recordings WHERE status = '{{status}}';

-- UPDATE V-KYC Recording
UPDATE vkyc_recordings
SET
    customer_name = '{{new_customer_name}}',
    recording_date = '{{new_recording_date}}',
    duration_seconds = {{new_duration_seconds}},
    file_path = '{{new_file_path}}',
    status = '{{new_status}}',
    metadata_json = '{{new_metadata_json}}'::JSONB
WHERE id = '{{vkyc_recording_id}}'
RETURNING id, vkyc_case_id, status;

-- DELETE V-KYC Recording
DELETE FROM vkyc_recordings WHERE id = '{{vkyc_recording_id}}' RETURNING id, vkyc_case_id;
-- Note: This will trigger the `log_vkyc_recording_changes` function to log the deletion.

-- =============================================================================
-- AUDIT_LOGS TABLE
-- =============================================================================

-- CREATE Audit Log (typically done by triggers or log_audit_event function)
-- Use the log_audit_event stored procedure for manual logging.
-- SELECT log_audit_event('{{user_id}}'::UUID, '{{action}}', '{{resource_type}}', '{{resource_id}}'::UUID, '{{ip_address}}'::INET, '{{details}}'::JSONB);
INSERT INTO audit_logs (user_id, action, resource_type, resource_id, ip_address, details)
VALUES ('{{user_id}}', '{{action}}', '{{resource_type}}', '{{resource_id}}', '{{ip_address}}', '{{details}}'::JSONB)
RETURNING id, timestamp;

-- READ Audit Logs
-- Get all audit logs (ordered by timestamp descending)
SELECT id, user_id, action, resource_type, resource_id, timestamp, ip_address, details FROM audit_logs ORDER BY timestamp DESC;
-- Get audit logs for a specific user
SELECT id, user_id, action, resource_type, resource_id, timestamp, ip_address, details FROM audit_logs WHERE user_id = '{{user_id}}' ORDER BY timestamp DESC;
-- Get audit logs for a specific resource
SELECT id, user_id, action, resource_type, resource_id, timestamp, ip_address, details FROM audit_logs WHERE resource_type = '{{resource_type}}' AND resource_id = '{{resource_id}}' ORDER BY timestamp DESC;
-- Get audit logs for a specific action type
SELECT id, user_id, action, resource_type, resource_id, timestamp, ip_address, details FROM audit_logs WHERE action = '{{action}}' ORDER BY timestamp DESC;
-- Get audit logs within a time range
SELECT id, user_id, action, resource_type, resource_id, timestamp, ip_address, details FROM audit_logs WHERE timestamp BETWEEN '{{start_timestamp}}' AND '{{end_timestamp}}' ORDER BY timestamp DESC;

-- UPDATE Audit Log (Generally not recommended for audit logs to maintain integrity)
-- If absolutely necessary, ensure strong justification and proper access controls.
-- Example (use with extreme caution):
-- UPDATE audit_logs SET details = '{"corrected_info": "true"}'::JSONB WHERE id = '{{audit_log_id}}';

-- DELETE Audit Log (Generally not recommended for audit logs to maintain integrity)
-- Audit logs are typically immutable. Deletion should only be for data retention policy compliance
-- and handled by automated processes, not manual CRUD.
-- Example (use with extreme caution):
-- DELETE FROM audit_logs WHERE id = '{{audit_log_id}}';
-- DELETE FROM audit_logs WHERE timestamp < '{{retention_date}}'; -- For retention policy